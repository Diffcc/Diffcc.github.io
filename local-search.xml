<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux/UNIX文件系统</title>
    <link href="/Diffcc/Diffcc.github.io/2025/06/07/20250607/"/>
    <url>/Diffcc/Diffcc.github.io/2025/06/07/20250607/</url>
    
    <content type="html"><![CDATA[<p><img src="linux.jpg" alt="linux"></p><p>文件系统给是对文件和目录的组织集合，</p><p>本文探究<strong>Linux</strong>下的设备文件系统，ext系列系统，日志文件系统设计</p><span id="more"></span><h2 id="设备文件系统"><a href="#设备文件系统" class="headerlink" title="设备文件系统"></a>设备文件系统</h2><h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><p>在Linux内核中，每种设备类型（真正存在or虚拟抽象）的都有与之对应的设备驱动程序，内核通过<strong>设备驱动程序</strong>的API接口，实现对于设备的操控，虽然每个设备都有差异，但是接口类似，进而能够很好的承接系统调用本身。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">/dev <span class="hljs-comment">#dev目录下设备文件</span><br><br><span class="hljs-comment">#超级用户使用mknod来创建设备文件</span><br></code></pre></td></tr></table></figure><p><img src="dev.png" alt="dev"></p><p>输入输出设备可分为两大类：<strong>块设备（<em>Block Device</em>）<strong>和</strong>字符设备（<em>Character Device</em>）</strong></p><ul><li>字符型设备基于每个字符来处理数据。终端、键盘、鼠标都属于字符型设备。</li><li>块设备每次处理一块设备。块的大小取决于设备类型，硬盘，USB都属于块设备。</li></ul><h3 id="磁盘设备"><a href="#磁盘设备" class="headerlink" title="磁盘设备"></a>磁盘设备</h3><p>磁盘由盘面，磁道，柱面和扇区构成，数据的读&#x2F;写按柱面进行，而不按盘面进行。也就是说，一个磁道写满数据后，就在同一柱面的下一个盘面来写，<em><strong>*一个柱面写满后，才移到下一个扇区开始写数据*</strong></em>。读数据也按照这种方式进行，这样就提高了硬盘的读&#x2F;写效率。</p><p><img src="disk.png" alt="disk"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk -l <span class="hljs-comment">#列出所有磁盘的分区</span><br></code></pre></td></tr></table></figure><p>磁盘分区可以容纳任何类型的信息，但通常只包含<strong>下面之一</strong>：</p><ul><li>文件系统：存放常规文件。</li><li>数据区域： 充当裸设备。</li><li>交换区域：内存管理之用 特权进程通过***swapon()<em><strong>和</strong></em>swapoff()***启动和停止磁盘分区操作。</li></ul><p>详情可参考：<a href="https://blog.csdn.net/hguisu/article/details/7408047">https://blog.csdn.net/hguisu/article/details/7408047</a></p><h3 id="ext系列文件系统"><a href="#ext系列文件系统" class="headerlink" title="ext系列文件系统"></a>ext系列文件系统</h3><p>**ext2（second extended file system）**扩展文件系统二世是Linux上使用最广泛的文件系统</p><p>ext2文件系统以<em><strong>block</strong></em>为基本单位，包括引导块，超级块，i节点表和数据块部分：</p><ul><li>引导块可以理解为Linux系统的<strong>init()</strong>，用来引导操作系统的信息。</li><li><strong>超级块</strong>则是标记了i节点表的大小，逻辑块的大小信息。</li><li><em><strong>i-list</strong></em>维护了文件类型、属主、硬链接数、<strong>指向文件数据块</strong>的指针等信息，在ext2中，每个i节点包括了15个指针，前12个指针用于直接索引文件数据库的位置，保证直接访问一击必中，后四个文件块通过指向一个<strong>指针块</strong>，分化为指向更多的数据块，以保证容纳大体量的文件，同时可以将未指向数据块的指针块中的指针标记未0，则无需未<strong>文件黑洞</strong>分配空字节数据块。</li><li><strong>数据块</strong>构成了文件和目录，用于存放数据。</li></ul><p><img src="inode.png" alt="inode"></p><p><img src="ext2.png" alt="ext2"></p><p><strong>ext3</strong>文件系统允许<code>journaling</code>日志，<code>journaling</code>日志是在文件系单独的区域存储，每当文件系统意外崩溃，采用<code>journaling</code>日志可以进行恢复，<strong>和ext2文件系统不同的是多出了<code>journaling</code>日志的功能</strong>。</p><ul><li>ext3提供三种journal日志模式，分别是<code>writeback</code>、<code>ordered</code>、<code>journal</code>.<code>writeback</code>仅仅会记录元数据的日志，数据可以直接写到磁盘，但是不保证数据比元数据先落盘，这也是性能最好的，但是<a href="https://cloud.tencent.com/product/dsgc?from_column=20065&from=20065">数据安全</a>性最低；<code>ordered</code>也是仅仅是记录元数据块的日志，这种模式是将文件的数据相关的元数据和数据在一个事务中，当元数据写入到磁盘时候，把对应的数据也写到磁盘，这样是先数据刷盘，再做元数据日志。<code>journal</code>提供数据和元数据的日志，所有的文件数据都先写到日志，然后在写到磁盘，数据需要写2次，性能是最差的。</li><li>ext2中在目录项中查找文件时间的复杂度是<code>O(n)</code>，ext3中采用了<code>h-trees</code>查找效率提高了很多</li></ul><p><img src="ext3.png" alt="ext3"></p><p><strong>ext4</strong>是从ext3 fork而来,针对ext4最大的feature就是ext4采用<code>extents</code>机制，替代了<code>indirect block</code>寻址的方式。ext4尽量会把<a href="https://cloud.tencent.com/product/cos?from_column=20065&from=20065">数据存储</a>在连续的block区域内，为了实现这个ext4需要知道三个信息，第一是文件的初始化block.其次是块的数量，最后是磁盘上初始化块的数据，这些信息统一抽象以<code>struct ext4_extent</code>呈现。</p><p><img src="ext4.png" alt="ext4"></p><p>详情可参考：<a href="https://cloud.tencent.com/developer/article/2074590">https://cloud.tencent.com/developer/article/2074590</a></p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>除了ext系列文件系统，还有诸如Reiserfs，VFAT，NFS等文件系统，为了能和各种文件系统打交道，应用程序通过<strong>虚拟文件系统（VFS</strong>）这一层抽象层中定义的通用接口（<em><strong>open()、read()、write()、lseek()</strong></em>….），来实现对不同文件系统的访问。</p><p>不同的文件系统对比可参考：<a href="https://zhuanlan.zhihu.com/p/689551298">https://zhuanlan.zhihu.com/p/689551298</a></p><p><img src="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png" alt="文件系统性能对比"></p><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p><strong>日志文件系统</strong>的作用在于避免了系统崩溃之后，为了确保文件系统的完整，需要遍历整个文件系统，来检查一致性（<em><strong>fcsk</strong></em>）。</p><p>日志文件系统会将更新操作记录在专门的磁盘日志文件中，可利用日志重做（<em><strong>redo</strong></em>）任何不完整更新（日志系统总能够保证将<strong>文件元数据事务</strong>作为一个完整单元提交至磁盘）。</p><h3 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h3><p>文件挂载（Mount）的作用是将存储设备（如硬盘分区、光盘、网络存储等）或虚拟文件系统（如<code>proc</code>、<code>sysfs</code>等）关联到目录树的某个位置（挂载点），使得用户和程序可以<strong>通过文件系统接口访问这些资源</strong>。</p><p><strong>Linux&#x2F;UNIX</strong>所有的文件系统中的文件都位于单根目录树下（<em><strong>”&#x2F;“</strong></em>），其他的文件系统都挂载在根目录下，被视为整个目录层级的子树（<em><strong>subtree</strong></em>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将device文件系统挂载在directory所指定的目录下</span><br>mount device directory<br><br><span class="hljs-comment"># mount用于列出当前已挂载的文件系统，unmount用于卸载</span><br>mount<br></code></pre></td></tr></table></figure><p><img src="mount.png" alt="mount"></p><p>用于查看当前已挂载和可挂载的文件信息：<code>/proc/mounts</code>，<code>/etc/mtab</code>，<code>/etc/fstab</code></p><p><img src="proc_mounts.png" alt="proc_mounts"></p><ul><li><strong>文件系统类型</strong>: <code>sysfs</code>（虚拟文件系统，用于导出内核对象信息）</li><li><strong>挂载点</strong>: <code>/sys</code></li><li><strong>文件系统类型</strong>: <code>sysfs</code></li><li><strong>挂载标志</strong>:<ul><li><code>rw</code>: 以读写方式挂载</li><li><code>nosuid</code>: 忽略文件系统中的SUID&#x2F;SGID权限位（禁用setuid&#x2F;setgid效果）</li><li><code>nodev</code>: 不允许解释文件系统上的设备文件（禁用设备文件）</li><li><code>noexec</code>: 禁止直接执行该文件系统上的程序</li><li><code>relatime</code>: 仅在访问时间早于修改时间时更新访问时间（优化性能）</li></ul></li><li><strong>数字字段</strong>:<ul><li><code>0</code>: dump备份标志（0表示不备份）</li><li><code>0</code>: fsck检查顺序（0表示不检查）</li></ul></li></ul><h4 id="高级挂载特性"><a href="#高级挂载特性" class="headerlink" title="高级挂载特性"></a>高级挂载特性</h4><p><strong>多个挂载点挂在文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/sda12 /test1<br>mount /dev/sda12 /test2<br><br><span class="hljs-comment">#在test1挂载点下操作，test2下完全可见</span><br></code></pre></td></tr></table></figure><p><strong>多次挂载同一挂载点</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">每次新挂载会隐藏之前可见于挂载点下的目录子树<br>mount /dev/sda12 /testfs<br>mount /dev/sda12 /testfs<br><br><span class="hljs-comment">#卸载最后一次挂载，上次挂载内容可见</span><br></code></pre></td></tr></table></figure><p><strong>基于每次挂载的挂载标志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#mountflag可以基于每次挂载来设置</span><br></code></pre></td></tr></table></figure><p><strong>绑定挂载</strong></p><p><strong>两处同时可见，类似于硬链接，但可以针对目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">MS_BIND<br>mount --<span class="hljs-built_in">bind</span><br></code></pre></td></tr></table></figure><p><strong>递归绑定挂载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">MS_BIND OR MS_REC<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux系统编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
