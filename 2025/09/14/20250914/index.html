

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="apple-touch-icon" sizes="76x76" href="../../../../img/ling.jpg">
  <link rel="icon" href="../../../../img/ling.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Diffcc">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++98&#x2F;03暴露出诸多不便的特性，为了能够适应现代编程环境和习惯的变化，C++也孕育出一系列新特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++新特性">
<meta property="og:url" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/index.html">
<meta property="og:site_name">
<meta property="og:description" content="C++98&#x2F;03暴露出诸多不便的特性，为了能够适应现代编程环境和习惯的变化，C++也孕育出一系列新特性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/tuple.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/lambda%E6%8D%95%E8%8E%B7%E5%BD%A2%E5%BC%8F.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/%E9%95%BF%E6%95%B4%E5%9E%8B.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/sharedptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/unique_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/weak_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B.png">
<meta property="og:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81.png">
<meta property="article:published_time" content="2025-09-14T13:47:19.000Z">
<meta property="article:modified_time" content="2025-09-14T14:24:49.669Z">
<meta property="article:author" content="Diffcc">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/tuple.png">
  
  
  
  <title>C++新特性 - </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="../../../../css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="../../../../css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="../../../../css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"github.com","root":"/Diffcc/Diffcc.github.io/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"KJGUBUZKqbURalPPi4RThE5j-gzGzoHsz","app_key":"LLhQIl1R0Kiu8YUUshoGpnuy","server_url":"https://kjgubuzk.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/Diffcc/Diffcc.github.io/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="../../../../js/utils.js" ></script>
  <script  src="../../../../js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="../../../../index.html">
      <strong>C.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../index.html" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="../../../../about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('../../../../img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++新特性"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-09-14 21:47" pubdate>
          2025年9月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          239 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++新特性</h1>
            
            
              <div class="markdown-body">
                
                <p>C++98/03暴露出诸多不便的特性，为了能够适应现代编程环境和习惯的变化，C++也孕育出一系列新特性。</p>
<span id="more"></span>
<h1>C++ 11新特性</h1>
<h2 id="C-auto">C++ auto</h2>
<p>在C++11之前, auto关键字用于指明变量的存储类型, 即自动存储的, 这也是编译器的默认规则, 和static关键字相对, 所以写不写都无关紧要.</p>
<p>C++11赋予auto新含义, 用于做自动类型推导, 编译器会在编译期间自动推导出变量的类型.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> name = value;  <span class="hljs-comment">// auto仅仅是一个占位符,在编译器期间会被真正的类型所替代</span><br></code></pre></td></tr></table></figure>
<p>可以连续定义多个变量, 但要注意二义性的问题:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">auto</span> *p = &amp;n, m = <span class="hljs-number">99</span>; <br><span class="hljs-comment">// 此时&amp;n的类型是int*, auto推倒为int, 后面的int m = 99也是正确的</span><br><span class="hljs-comment">// 如果此时m = 99.9, 则会报错(double和int不匹配)</span><br></code></pre></td></tr></table></figure>
<p>还需要注意的是, 使用auto类型推导的变量必须马上初始化, 因为只有初始化之后, 才能明确auto的类型.</p>
<p>auto用于推倒引用以及和const一起使用时, 有如下特点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 当 = 右边表达式是一个引用类型, auto会把引用抛弃, 直接推导出他的原始类型</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> &amp;r1 = x;  <span class="hljs-comment">// r1为int&amp;</span><br><span class="hljs-keyword">auto</span> r2 = r1;  <span class="hljs-comment">// 抛弃引用 auto为int</span><br><span class="hljs-comment">// 当 = 右边类型不为引用时, 其const属性会被抛弃</span><br><span class="hljs-comment">// 当 = 右边类型包含引用时, 其const属性会被保留</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> n = x;  <span class="hljs-comment">// auto 为 int, n的类型为const int</span><br><span class="hljs-keyword">auto</span> f = n;  <span class="hljs-comment">// auto 推导为int const属性被抛弃</span><br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;r1 = x;<br><span class="hljs-keyword">auto</span> &amp;r2 = r1; <span class="hljs-comment">// r1 为const int&amp; 此时auto推导为const int, const不被抛弃</span><br></code></pre></td></tr></table></figure>
<p>使用auto时, 必须对变量进行初始化之外, auto还存在以下限制:</p>
<ol>
<li>auto不能在函数的参数中使用 (本质上还是没有初始化)</li>
<li>auto不能作用于类的非静态成员变量(也就是没有static关键字修饰的成员变量中)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 对于非静态成员变量, 它们初始化表达式不是在类定义阶段就执行, 而是在对象构造阶段</span><br><span class="hljs-comment">// 而auto依赖于变量定义时的初始化表达式, static不依赖于具体对象, 定义时就能确定类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 编译错误</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> y = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 合法 y是int</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li>auto关键字不能定义数组</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 错误</span><br><span class="hljs-type">char</span> ur[] = <span class="hljs-string">&quot;https://diffcc.github.io/&quot;</span>;<br><span class="hljs-keyword">auto</span> str[] = url;<br></code></pre></td></tr></table></figure>
<ol>
<li>auto不能作用于模板参数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A&lt;<span class="hljs-type">int</span>&gt; C1;<br>    A&lt;<span class="hljs-keyword">auto</span>&gt; C2 = C1;  <span class="hljs-comment">// 错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>auto常用的两个用法:</p>
<ol>
<li>使用auto定义容器的迭代器, 迭代器的书写冗长且复杂</li>
<li>auto用于泛型编程, 当我们不知道变量是什么类型, 或者不希望指明具体类型的时候</li>
</ol>
<h2 id="C-decltype">C++ decltype</h2>
<p>C++ decltype和auto功能一样, 都是用来在编译期进行自动类型推导, 和auto使用的区别如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// auto根据右边value推导出变量类型</span><br><span class="hljs-comment">// decltype根据exp表达式推导出变量的类型, 与右边的value没有关系</span><br><span class="hljs-keyword">auto</span> varname = value;<br><span class="hljs-keyword">decltype</span>(exp) varname = value;<br><br><span class="hljs-comment">// 因此和value无关 decltype不要求初始化</span><br><span class="hljs-keyword">decltype</span>(exp) varname;<br><br><span class="hljs-comment">// exp调用的返回类型不能是void, 会导致编译错误</span><br></code></pre></td></tr></table></figure>
<p>decltype的推导规则有如下三条:</p>
<ol>
<li>如果exp是一个不被括号( )包围的表达式, 或者是一个类成员访问表达式, 或者是一个单独的变量, 那么decltype(exp)类型就和exp一致, 这是最普遍最常见的情况.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> total;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">float</span> scores;<br>&#125;;<br><span class="hljs-type">int</span> Student::total = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r = n;<br>    Student stu;<br>    <span class="hljs-keyword">decltype</span>(n) a = n;  <span class="hljs-comment">//n 为 int 类型，a 被推导为 int 类型</span><br>    <span class="hljs-keyword">decltype</span>(r) b = n;     <span class="hljs-comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span><br>    <span class="hljs-keyword">decltype</span>(Student::total) c = <span class="hljs-number">0</span>;  <span class="hljs-comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span><br>    <span class="hljs-keyword">decltype</span>(stu.name) url = <span class="hljs-string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="hljs-comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>如果exp是函数调用, 那么decltype(exp)的类型就和函数返回值的类型一致</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">/函数声明<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">func_int_r</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>)</span></span>;  <span class="hljs-comment">//返回值为 int&amp;</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">func_int_rr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;  <span class="hljs-comment">//返回值为 int&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func_int</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;  <span class="hljs-comment">//返回值为 int</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">fun_cint_r</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">//返回值为 const int&amp;</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">func_cint_rr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;  <span class="hljs-comment">//返回值为 const int&amp;&amp;</span><br><span class="hljs-comment">//decltype类型推导</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_int_r</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;A&#x27;</span>)) a = n;  <span class="hljs-comment">//a 的类型为 int&amp;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_int_rr</span>()) b = <span class="hljs-number">0</span>;  <span class="hljs-comment">//b 的类型为 int&amp;&amp;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_int</span>(<span class="hljs-number">10.5</span>)) c = <span class="hljs-number">0</span>;   <span class="hljs-comment">//c 的类型为 int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">fun_cint_r</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))  x = n;    <span class="hljs-comment">//x 的类型为 const int &amp;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func_cint_rr</span>()) y = <span class="hljs-number">0</span>;  <span class="hljs-comment">// y 的类型为 const int&amp;&amp;</span><br></code></pre></td></tr></table></figure>
<p>需要注意的是, exp中调用函数需要带上括号和参数, 这仅仅是形式, <strong>但不会真的去执行函数代码</strong></p>
<ol>
<li>exp是左值, 或者被括号( )包围, 那么decltype(exp)的类型就是exp的引用；假设exp的类型是 T, 那么decltype(exp)的类型就是T &amp;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> Base obj;<br>    <span class="hljs-comment">//带有括号的表达式</span><br>    <span class="hljs-keyword">decltype</span>(obj.x) a = <span class="hljs-number">0</span>;  <span class="hljs-comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span><br>    <span class="hljs-keyword">decltype</span>((obj.x)) b = a;  <span class="hljs-comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span><br>    <span class="hljs-comment">//加法表达式</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">decltype</span>(n + m) c = <span class="hljs-number">0</span>;  <span class="hljs-comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span><br>    <span class="hljs-keyword">decltype</span>(n = n + m) d = c;  <span class="hljs-comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>decltype实际运用中用于替代auto只能用于类的静态成员, 不能用于类的非静态成员的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp; container)</span> </span>&#123;<br>        m_it = container.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typename</span> T::iterator m_it;  <span class="hljs-comment">//注意这里</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    Base&lt;<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&gt; obj;<br>    obj.<span class="hljs-built_in">func</span>(v);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;        <br><br><span class="hljs-comment">// 上述代码T::iterator并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 </span><br><span class="hljs-comment">// const_iterator</span><br><span class="hljs-comment">// 可以采用以下的写法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp; container)</span> </span>&#123;<br>        m_it = container.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">T</span>().<span class="hljs-built_in">begin</span>()) m_it;  <span class="hljs-comment">//注意这里</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>auto和decltype的区别在于:</p>
<ol>
<li>对于cv限定符: const 和 volatile (const 关键字用于表示数据是只读的, 也就是不能修改, volatile表明数据是可变的, 易变的, 目的是不让CPU将数据缓存到寄存器, 而是从原始的内存中读取) decltype会保留cv限定符 auto对于表达式类型是指针或者引用, auto会保留cv限定符, 如果表达式类型不是指针或者引用, auto会把cv限定符抛弃, 推导成non-const或者non-volatile类型</li>
<li>对于引用的处理: decltype会保留引用类型, 而auto会抛弃引用类型</li>
</ol>
<p>总结来说: auto书写形式简单直观, 如果表达式类型不复杂, auto关键字比较优雅, 但是decltype比较纯粹, 一般会坚持保留原始表达式的任何类型, 让代码更加健壮</p>
<h2 id="C-返回值类型后置">C++返回值类型后置</h2>
<p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> t + u;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11对模板实例化中连续右尖括号-的改进">C++11对模板实例化中连续右尖括号&gt;&gt;的改进</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>      <span class="hljs-keyword">typedef</span> T type;<br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Foo&lt;A&lt;<span class="hljs-type">int</span>&gt;&gt;::type xx;  <span class="hljs-comment">//从c++98编译出错, 解释成移位符号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11使用using定义别名（替代typedef）">C++11使用using定义别名（替代typedef）</h2>
<p>在C++中, typedef常用于重定义一个类型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint_t</span>;<br><br><span class="hljs-comment">// 重定义的类型并不是一个新的类型, 仅仅是原有的类型的一个新名字</span><br><span class="hljs-comment">// 所以下面并不是合法的重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">uint_t</span>)</span></span>; <span class="hljs-comment">// error: redefinition</span><br></code></pre></td></tr></table></figure>
<p>typedef有其不便性, 比如无法重定义一个模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> std::map&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-type">map_int_t</span>;<br><span class="hljs-keyword">typedef</span> std::map&lt;std::string, std::string&gt; <span class="hljs-type">map_str_t</span>;<br><br><span class="hljs-comment">// 在C++98中可以这样优化上述</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Val&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">str_map</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> std::map&lt;std::string, Val&gt; type;<br>&#125;;<br><span class="hljs-comment">// ...</span><br>str_map&lt;<span class="hljs-type">int</span>&gt;::type map1;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 不得不使用一个外敷类来泛化上述功能代码</span><br><span class="hljs-comment">// 而使用using 则不需要这个外敷类</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Val&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-type">str_map_t</span> = std::map&lt;std::string, Val&gt;;<br><span class="hljs-comment">// ...</span><br><span class="hljs-type">str_map_t</span>&lt;<span class="hljs-type">int</span>&gt; map1;<br></code></pre></td></tr></table></figure>
<p>总的来说, using可以覆盖所有typedef的功能, 而且对于定义模板别名来说, 不需要通过外敷模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 重定义unsigned int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint_t</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-type">uint_t</span> = <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">// 重定义std::map</span><br><span class="hljs-keyword">typedef</span> std::map&lt;std::string, <span class="hljs-type">int</span>&gt; <span class="hljs-type">map_int_t</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-type">map_int_t</span> = std::map&lt;std::string, <span class="hljs-type">int</span>&gt;;<br></code></pre></td></tr></table></figure>
<h2 id="C-11支持函数模板的默认模板参数">C++11支持函数模板的默认模板参数</h2>
<p>在C++98中, 类模板可以有默认的模板参数, 但是却不支持函数的默认模板参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U = <span class="hljs-type">int</span>, U N = <span class="hljs-number">0</span>&gt;<br><span class="hljs-keyword">struct</span> Foo<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;  <span class="hljs-comment">// error in C++98/03: default template arguments</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">func</span>()<br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>(<span class="hljs-type">void</span>)<br>&#123;<br>    <span class="hljs-built_in">func</span>();   <span class="hljs-comment">//T = int</span><br>    <span class="hljs-comment">// 对于类模板而言, 即使所有的参数都有默认参数, 在使用时也必须在模板名后跟随&lt;&gt;来实例化</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对此, 我们可以指定函数中的一部分模板参数采用默认模板参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go">template &lt;typename R = <span class="hljs-type">int</span>, typename U&gt;<br>R <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(U val)</span></span><br>&#123;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(97)</span></span>;               <span class="hljs-comment">// R=int, U=int</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span>&lt;<span class="hljs-title">char</span>&gt;<span class="hljs-params">(97)</span></span>;         <span class="hljs-comment">// R=char, U=int</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span>&lt;<span class="hljs-title">double</span>, <span class="hljs-title">int</span>&gt;<span class="hljs-params">(97)</span></span>;  <span class="hljs-comment">// R=double, U=int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11在函数模板和类模板中使用可变参数">C++11在函数模板和类模板中使用可变参数</h2>
<p>所谓可变参数, 指的是参数的个数和类型都是任意的, 例如printf()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %c %f&quot;</span>,<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1.23</span>);<br><span class="hljs-comment">// 可变参数函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vair_fun</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 可变参数中包含如下三个宏</span></span><br><span class="hljs-function"><span class="hljs-title">va_start</span><span class="hljs-params">(args, count)</span> <span class="hljs-comment">// args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">va_arg</span><span class="hljs-params">(args, <span class="hljs-type">int</span>)</span>  <span class="hljs-comment">// 调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">va_end</span><span class="hljs-params">(args)</span>  <span class="hljs-comment">// 不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</span></span><br></code></pre></td></tr></table></figure>
<p>使用…可变参数, 需要注意以下几点:</p>
<ol>
<li>… 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数</li>
<li>可变参数的前面至少要有 1 个有名参数（例如上面例子中的 count 参数）</li>
<li>当可变参数中包含 char 类型的参数时，va_arg 宏要以 int 类型的方式读取；当可变参数中包含 short 类型的参数时，va_arg 宏要以 double 类型的方式读取</li>
</ol>
<p>C++11标准发布之前, 函数模板和类模板只能设定固定数量的模板参数, C++11标准对模板的功能进行了扩展, 运行模板中包含任意数量的模板参数</p>
<p><strong>可变参数函数模板:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vair_fun</span><span class="hljs-params">(T...args)</span> </span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br><br><span class="hljs-built_in">vair_fun</span>();<br><span class="hljs-built_in">vair_fun</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-built_in">vair_fun</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1.23</span>);<br><span class="hljs-comment">// 使用可变参数模板的难点在于, 如何在模板函数内部解开参数包</span><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//模板函数递归的出口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vir_fun</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vir_fun</span><span class="hljs-params">(T argc, args... argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; argc &lt;&lt; endl;<br>    <span class="hljs-comment">//开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun</span><br>    <span class="hljs-built_in">vir_fun</span>(argv...);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vir_fun</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;http://www.biancheng.net&quot;</span>, <span class="hljs-number">2.34</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 方法二 借助逗号表达式和初始化列表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dispaly</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    cout &lt;&lt; t &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vir_fun</span><span class="hljs-params">(args... argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//逗号表达式+初始化列表</span><br>    <span class="hljs-type">int</span> arr[] = &#123; (<span class="hljs-built_in">dispaly</span>(argv),<span class="hljs-number">0</span>)... &#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vir_fun</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;http://www.biancheng.net&quot;</span>, <span class="hljs-number">2.34</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// &#123; &#125;初始化列表的方式对数组 arr 进行了初始化， (display(argv),0)… 会依次展开为 (display(1),0)、(display(“http://www.biancheng.net”),0) 和 (display(2.34),0)</span><br><br> <span class="hljs-type">int</span> arr[] = &#123; (<span class="hljs-built_in">dispaly</span>(<span class="hljs-number">1</span>),<span class="hljs-number">0</span>), (<span class="hljs-built_in">dispaly</span>(<span class="hljs-string">&quot;http://www.biancheng.net&quot;</span>),<span class="hljs-number">0</span>), (<span class="hljs-built_in">dispaly</span>(<span class="hljs-number">2.34</span>),<span class="hljs-number">0</span>) &#125;;<br><span class="hljs-comment">// 每个元素都是一个逗号表达式，以 (display(1), 0) 为例，它会先计算 display(1)，然后将 0 作为整个表达式的值返回给数组，因此 arr 数组最终存储的都是 0。arr 数组纯粹是为了将参数包展开，没有发挥其它作用</span><br></code></pre></td></tr></table></figure>
<p><strong>可变参数类模板:</strong></p>
<p>在C++11中, 类模板的模板参数也可以是一个可变参数, C++11标准提供的typle元组类就是一个典型的可变参数模板类:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">tuple</span>;<br><br>std:tuple&lt;&gt; tp0;<br>std::tuple&lt;<span class="hljs-type">int</span>&gt; tp1 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>);<br>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; tp2 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.34</span>);<br>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, string&gt; tp3 = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.34</span>, <span class="hljs-string">&quot;http://www.biancheng.net&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>下面是一个支持可变参数的类模板:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//声明模板类demo</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Values&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>;<br><span class="hljs-comment">//继承式递归的出口</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&lt;&gt; &#123;&#125;;<br><span class="hljs-comment">//以继承的方式解包</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Head, <span class="hljs-keyword">typename</span>... Tail&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&lt;Head, Tail...&gt;<br>    : <span class="hljs-keyword">private</span> demo&lt;Tail...&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>(Head v, Tail... vtail) : <span class="hljs-built_in">m_head</span>(v), <span class="hljs-built_in">demo</span>&lt;Tail...&gt;(vtail...) &#123;<br>        <span class="hljs-built_in">dis_head</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis_head</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; m_head &lt;&lt; std::endl; &#125;<br><span class="hljs-keyword">protected</span>:<br>    Head m_head;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">demo&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, std::string&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.34</span>, <span class="hljs-string">&quot;http://www.biancheng.net&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11-tuple元组">C++11 tuple元组</h2>
<p>tuple最大的特点是: 实例化的对象可以存储任意数量, 任意类型的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-keyword">using</span> std::tuple<br><br><span class="hljs-comment">// tuple模板类提供如下构造函数:</span><br><span class="hljs-number">1</span>) 默认构造函数<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">tuple</span><span class="hljs-params">()</span></span>;<br><span class="hljs-number">2</span>) 拷贝构造函数<br><span class="hljs-built_in">tuple</span> (<span class="hljs-type">const</span> tuple&amp; tpl);<br><span class="hljs-number">3</span>) 移动构造函数<br><span class="hljs-built_in">tuple</span> (tuple&amp;&amp; tpl);<br><span class="hljs-number">4</span>) 隐式类型转换构造函数<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... UTypes&gt;<br>    <span class="hljs-built_in">tuple</span> (<span class="hljs-type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="hljs-comment">//左值方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... UTypes&gt;<br>    <span class="hljs-built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="hljs-comment">//右值方式</span><br><span class="hljs-number">5</span>) 支持初始化列表的构造函数<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">tuple</span> <span class="hljs-params">(<span class="hljs-type">const</span> Types&amp;... elems)</span></span>;  <span class="hljs-comment">//左值方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... UTypes&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">tuple</span> <span class="hljs-params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="hljs-comment">//右值方式</span><br><span class="hljs-number">6</span>) 将pair对象转换为tuple对象<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br>    <span class="hljs-built_in">tuple</span> (<span class="hljs-type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="hljs-comment">//左值方式</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">U1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">U2</span>&gt;<br>    <span class="hljs-built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="hljs-comment">//右值方式</span><br>    <br><span class="hljs-comment">// 使用如下</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>     <span class="hljs-comment">// std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span>        <span class="hljs-comment">// std::tuple</span></span><br><span class="hljs-keyword">using</span> std::tuple;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; first;                             <span class="hljs-comment">// 1)   first&#123;&#125;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">second</span><span class="hljs-params">(first)</span></span>;                     <span class="hljs-comment">// 2)   second&#123;&#125;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">third</span><span class="hljs-params">(std::make_tuple(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;b&#x27;</span>))</span></span>;   <span class="hljs-comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">long</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">fourth</span><span class="hljs-params">(third)</span></span>;                    <span class="hljs-comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">fifth</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;                    <span class="hljs-comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">sixth</span><span class="hljs-params">(std::make_pair(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;c&#x27;</span>))</span></span>;    <span class="hljs-comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>make_tuple() 用于chungking一个tuple右值对象(或者临时对象)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> first = std::<span class="hljs-built_in">make_tuple</span> (<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>);   <span class="hljs-comment">// tuple &lt; int, char &gt;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> b[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">auto</span> second = std::<span class="hljs-built_in">make_tuple</span> (a,b);     <span class="hljs-comment">// tuple &lt; int, int* &gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>tuple常用函数:</strong></p>
<p><img src="tuple.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="tuple" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span><br>    <span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">mytuple</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;x&#x27;</span>)</span></span>;<br>    <span class="hljs-comment">//计算 mytuple 存储元素的个数</span><br>    size = std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(mytuple)&gt;::value;<br>    <span class="hljs-comment">//输出 mytuple 中存储的元素</span><br>    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(mytuple) &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(mytuple) &lt;&lt; std::endl;<br>    <span class="hljs-comment">//修改指定的元素</span><br>    std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(mytuple) = <span class="hljs-number">100</span>;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(mytuple) &lt;&lt; std::endl;<br>    <span class="hljs-comment">//使用 makde_tuple() 创建一个 tuple 对象</span><br>    <span class="hljs-keyword">auto</span> bar = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">14</span>);<br>    <span class="hljs-comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mystr = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">double</span> mydou;<br>    <span class="hljs-type">int</span> myint;<br>    <span class="hljs-comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span><br>    std::<span class="hljs-built_in">tie</span>(mystr, mydou, myint) = bar;<br>    <span class="hljs-comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span><br>    <span class="hljs-comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span><br>    <span class="hljs-keyword">auto</span> mycat = std::<span class="hljs-built_in">tuple_cat</span>(mytuple, bar);<br>    size = std::tuple_size&lt;<span class="hljs-keyword">decltype</span>(mycat)&gt;::value;<br>    std::cout &lt;&lt; size &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11列表初始化-同一初始化方式">C++11列表初始化(同一初始化方式)</h2>
<p>在C++98中， 对于普通数组和POD类型(plain old data，简单来说就是可以直接使用memcpy复制的对象)，可以使用初始化列表（initializer list）进行初始化，C++11提出列表初始化（List-initialization），初始化列表的适用性被大大增加了，可以用于任何类型对象的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo &amp;);<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>    Foo a2 = <span class="hljs-number">123</span>;  <span class="hljs-comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span><br>    Foo a3 = &#123; <span class="hljs-number">123</span> &#125;;<br>    Foo a4 &#123; <span class="hljs-number">123</span> &#125;;<br>    <span class="hljs-type">int</span> a5 = &#123; <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-type">int</span> a6 &#123; <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在初始化时，{}前面的等于号是否书写对于 初始化行为没有影响。</p>
<p>除了上述内容，列表初始化还可以直接用在函数的返回值上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span><br>&#123;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>, <span class="hljs-type">double</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-function">Foo <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">123</span>, <span class="hljs-number">321.0</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11-lambda匿名函数">C++11 lambda匿名函数</h2>
<p>语法格式：[外部变量访问方式说明符]（参数）muable noexcept/throw()-&gt;返回值类型{函数体;};</p>
<p>外部变量的访问有[=]和[&amp;]两种访问方式</p>
<p>noexcept和throw表明是否会抛出异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> except = []()<span class="hljs-built_in">throw</span>(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-number">10</span>;<br>    &#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">except</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获到了整形异常&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 可以捕获到整形异常</span><br></code></pre></td></tr></table></figure>
<p><img src="lambda%E6%8D%95%E8%8E%B7%E5%BD%A2%E5%BC%8F.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="lambda捕获形式" /></p>
<p>lambda函数内部可以访问全局变量并且修改，如果按值传递[=], 实际上内部是局部变量的备份，并且是const的，不能赋值修改，如果按照引用传递[&amp;], 则可以修改局部变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> all_num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//局部变量</span><br>    <span class="hljs-type">int</span> num_1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> num_2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> num_3 = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;lambda1:\n&quot;</span>;<br>    <span class="hljs-keyword">auto</span> lambda1 = [=]&#123;<br>        <span class="hljs-comment">//全局变量可以访问甚至修改</span><br>        all_num = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//函数体内只能使用外部变量，而无法对它们进行修改</span><br>        cout &lt;&lt; num_1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>             &lt;&lt; num_2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>             &lt;&lt; num_3 &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">lambda1</span>();<br>    cout &lt;&lt; all_num &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;lambda2:\n&quot;</span>;<br>    <span class="hljs-keyword">auto</span> lambda2 = [&amp;]&#123;<br>        all_num = <span class="hljs-number">100</span>;<br>        num_1 = <span class="hljs-number">10</span>;<br>        num_2 = <span class="hljs-number">20</span>;<br>        num_3 = <span class="hljs-number">30</span>;<br>        cout &lt;&lt; num_1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>             &lt;&lt; num_2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>             &lt;&lt; num_3 &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-built_in">lambda2</span>();<br>    cout &lt;&lt; all_num &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果想修改[=]按值传递的变量的值，可以使用mutable关键字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> lambda1 = [=]() <span class="hljs-keyword">mutable</span>&#123;<br>    num_1 = <span class="hljs-number">10</span>;<br>    num_2 = <span class="hljs-number">20</span>;<br>    num_3 = <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">//函数体内只能使用外部变量，而无法对它们进行修改</span><br>    cout &lt;&lt; num_1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>         &lt;&lt; num_2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>         &lt;&lt; num_3 &lt;&lt; endl;<br>&#125;;<br><span class="hljs-comment">//  但是也只是修改的局部变量的备份</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11非受限联合体">C++11非受限联合体</h2>
<p>在C++中，联合体（Union）是一种构造数据类型，在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间</p>
<p>在老版本的C++中，对C++联合体的数据类型有较大的限制</p>
<p>C++11取消了这些限制，任何非引用类型都可以称为联合体的数据成员，这种联合体也被称为<strong>非受限联合体</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">bool</span> g, <span class="hljs-type">int</span> a): <span class="hljs-built_in">gender</span>(g), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> gender;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">T</span>&#123;<br>    Student s;  <span class="hljs-comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>C++11<strong><strong>允许非</strong></strong>POD****数据：</strong></p>
<p>POD数据有如下特性（包括class，union，struct）“平凡的，标准布局的，通过memcpy拷贝，不会出现问题”：</p>
<ol>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数</li>
<li>不能包含虚函数和虚基类</li>
<li>非静态成员必须声明为 public</li>
<li>类中的第一个非静态成员的类型与其基类不同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span> : B1 &#123; B1 b; &#125;;<br><span class="hljs-comment">// class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型</span><br></code></pre></td></tr></table></figure>
<ol>
<li>在类或者结构体继承时，满足以下两种情况之一: · 派生类有非静态成员，且只有一个仅包含静态成员的基类 · 基类有非静态成员，而派生类没有非静态成员</li>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</li>
<li>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）</li>
</ol>
<p><strong>C++11****允许联合体有静态成员：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>C++11规定，如果非受限联合体内有一个非POD成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数，拷贝赋值操作符以及析构函数，也将被删除</p>
<p>这条规则可能导致对象构造失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    string s;<br>    <span class="hljs-type">int</span> n;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    U u;   <span class="hljs-comment">// 构造失败，因为 U 的构造函数被删除</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 因为string类拥有自定义的构造函数，所以U的构造函数被删除，定义U的类型变量u</span><br><span class="hljs-comment">// 需要调用默认构造函数，所以u也无法定义成功</span><br></code></pre></td></tr></table></figure>
<p>解决上述问题，需要用到placement new</p>
<p>Placement new是new关键字的一种进阶用法，既可以在栈上生成对象，也可以在堆上生成对象，而常见的new的用法是operator new，只能在heap上生成对象</p>
<p>Placement new的语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">new</span>(address)  <span class="hljs-built_in">ClassConstruct</span>(...)<br><span class="hljs-comment">// address表示已有内存的地址，该内存可以在栈上，也可以在堆上</span><br><span class="hljs-comment">// ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号</span><br><span class="hljs-comment">// placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，</span><br><span class="hljs-comment">// 而是将对象数据放在 address 指定的内存中</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    string s;<br>    <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">U</span>() &#123; <span class="hljs-keyword">new</span>(&amp;s) string; &#125;<br>    ~<span class="hljs-built_in">U</span>() &#123; s.~<span class="hljs-built_in">string</span>(); &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    U u;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，</span><br><span class="hljs-comment">// 这里 placement new 的唯一作用只是调用了一下 string 类的构造函数</span><br></code></pre></td></tr></table></figure>
<p>匿名联合体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span>&#123;<br><span class="hljs-keyword">union</span> &#123; <span class="hljs-type">int</span> x; &#125;; <span class="hljs-comment">//此联合体为匿名联合体</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">bool</span> g, <span class="hljs-type">int</span> a): <span class="hljs-built_in">gender</span>(g), <span class="hljs-built_in">age</span>(a)&#123;&#125;<br>    <span class="hljs-type">bool</span> gender;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-type">bool</span> g, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">s</span>(g, a) &#123; t = STUDENT; &#125;<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">id</span>(i) &#123; t = NATIVE; &#125;<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* n, <span class="hljs-type">int</span> s) &#123;<br>        <span class="hljs-type">int</span> size = (s &gt; <span class="hljs-number">9</span>) ? <span class="hljs-number">9</span> : s;<br>        <span class="hljs-built_in">memcpy</span>(name , n, size);<br>        name[s] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        t = FOREIGENR;<br>    &#125;<br>    ~<span class="hljs-built_in">Singer</span>()&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Type t;<br>    <span class="hljs-keyword">union</span> &#123;<br>        Student s;<br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br>    &#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">13</span>);<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-number">310217</span>);<br>    <span class="hljs-built_in">Singer</span>(<span class="hljs-string">&quot;J Michael&quot;</span>, <span class="hljs-number">9</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 上面的代码中使用了一个匿名非受限联合体，作为类Singer的“变长成员”来使用，这样的</span><br><span class="hljs-comment">// 变长成员给类的编写带来很大的灵活性</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11-for循环">C++11 for循环</h2>
<p>C++11中使用如下结构的语法，来替代原本通过index索引的for循环结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">for</span> (declaration : expression)&#123;<br><span class="hljs-comment">//循环体</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 支持&#123; &#125;大括号出初始化的列表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><span class="hljs-comment">// 遍历容器 实际上是容器内存储的元素</span><br><span class="hljs-comment">// for循环遍历 vector 容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : myvector) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br><br><span class="hljs-comment">// 使用新语法格式的 for 循环遍历某个序列时，</span><br><span class="hljs-comment">// 如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量</span><br>    vector&lt;<span class="hljs-type">char</span>&gt;<span class="hljs-built_in">myvector</span>(arc, arc + <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ch : myvector) &#123;<br>        ch++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义const &amp;（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>
<p>使用for循环时，有如下注意点：</p>
<ol>
<li>for 循环冒号后还可以放置返回 string 字符串以及容器对象的函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string str = <span class="hljs-string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; myvector = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">string <span class="hljs-title">retStr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">retVector</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> myvector;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//遍历函数返回的 string 字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : <span class="hljs-built_in">retStr</span>()) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-comment">//遍历函数返回的 vector 容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : <span class="hljs-built_in">retVector</span>()) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>基于范围的 for 循环不支持遍历函数返回的以指针形式表示的数组，因为for循环只能遍历有明确范围的一组数据</p>
</li>
<li>
<p>当基于范围的 for 循环遍历的是某函数返回的 string 对象或者容器时，整个遍历过程中，函数只会执行一次</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string str= <span class="hljs-string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">retStr</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;retStr:&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//遍历函数返回的 string 字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : <span class="hljs-built_in">retStr</span>()) &#123;<br>        cout &lt;&lt; ch;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// retStr() 函数仅在遍历开始前执行了 1 次</span><br>retStr:<br>http:<span class="hljs-comment">//c.biancheng.net/cplus/11/</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>对于关联式容器： 不允许修改 map、unordered_map、multimap 以及 unordered_multimap 容器存储的键的值； 不允许修改 set、unordered_set、multiset 以及 unordered_multiset 容器中存储的元素的值。 遍历此类型容器时，切勿修改容器内不允许修改的数据部分，否则会导致程序的执行出现各种BUG</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt;arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : arr)<br>    &#123;<br>        std::cout &lt;&lt; val &lt;&lt; std::endl;<br>        arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//向容器中添加元素</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// for 循环遍历 arr 容器的同时向该容器尾部添加了新的元素（对 arr 容器进行了扩增），</span><br><span class="hljs-comment">// 致使遍历容器所使用的迭代器失效，整个遍历过程出现错误。</span><br><span class="hljs-number">1</span><br><span class="hljs-number">-572662307</span><br><span class="hljs-number">-572662307</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11-constexpr-验证是否常量表达式">C++11 constexpr: 验证是否常量表达式</h2>
<p>常量表达式指的是有多个（≥1）常量组成的表达式，常量表达式一旦确认，其值将无法修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 1)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">10</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 2)</span><br><span class="hljs-type">int</span> url[<span class="hljs-number">6</span> + <span class="hljs-number">4</span>];<span class="hljs-comment">//正确</span><br><span class="hljs-comment">// 3)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><span class="hljs-type">int</span> url[length];<span class="hljs-comment">//错误，length是变量</span><br></code></pre></td></tr></table></figure>
<p>非常量表达式只能在<strong>程序运行阶段</strong>计算出结果；而常量表达式的计算往往发生在<strong>程序的编译阶段</strong></p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段(最主要的还是为了提高性能)</p>
<p><strong>constexpr修饰****普通变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> num = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> url[num] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    couts&lt;&lt; url[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 利用constexpr修饰的上述num是常量，可以用于数组</span><br></code></pre></td></tr></table></figure>
<p><strong>constexpr修饰函数</strong></p>
<p>constexpr修饰函数返回值，这样的函数被称为“常量表达式函数”，一个函数想要成为常量表达式，必须满足下面四个条件：</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 包含了两条语句 无法通过编译</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + x;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 只包含一条return语句 可以通过编译</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + x;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>该函数必须有返回值，并且函数返回值的类型不能是void</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 不属于常量表达式函数</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>函数在使用之前，必须有对应的定义语句（对于普通函数来讲，函数调用之前看到声明即可，定义可以放在后面，而对于常量表达式函数，必须在调用之前看到对应的定义）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//普通函数的声明</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">noconst_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-comment">//常量表达式函数的声明</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-comment">//常量表达式函数的定义</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//调用常量表达式函数</span><br>    <span class="hljs-type">int</span> a[<span class="hljs-built_in">display</span>(<span class="hljs-number">3</span>)] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>    cout &lt;&lt; a[<span class="hljs-number">2</span>] &lt;&lt; endl;<br>    <span class="hljs-comment">//调用普通函数</span><br>    cout &lt;&lt; <span class="hljs-built_in">noconst_dis</span>(<span class="hljs-number">3</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//普通函数的定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">noconst_dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + x;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>return返回的表达式必须是个常量表达式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> num = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> num + x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//调用常量表达式函数</span><br>    <span class="hljs-type">int</span> a[<span class="hljs-built_in">display</span>(<span class="hljs-number">3</span>)] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常</span><br></code></pre></td></tr></table></figure>
<p><strong>constexpr修饰类的构造函数</strong></p>
<p>对于C++内置类型的数据, 可以直接使用constexpr修饰, 但是如果是自定义的数据类型, 直接用constexpr修饰是不行的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//自定义类型的定义</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//其它结构体成员</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> mt &#123; <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">10</span> &#125;;<br>    cout &lt;&lt; mt.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 上述程序无法通过编译, 编译器会抛出&quot;constexpr不能修饰自定义类型&quot;的异常</span><br></code></pre></td></tr></table></figure>
<p>正确的做法是在该类型内部添加一个常量构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//自定义类型的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">myType</span><span class="hljs-params">(<span class="hljs-type">char</span> *name,<span class="hljs-type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//其它结构体成员</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> mt &#123; <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">10</span> &#125;;<br>    cout &lt;&lt; mt.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样的, constexpr也可以修饰类中的成员函数, 但是需要满足上述提到的4个条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//自定义类型的定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myType</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">myType</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<span class="hljs-type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">getname</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//其它结构体成员</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> mt &#123; <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name = mt.<span class="hljs-built_in">getname</span>();<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> age = mt.<span class="hljs-built_in">getage</span>();<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>constexpr修饰模板函数</strong></p>
<p>constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//自定义类型的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//其它结构体成员</span><br>&#125;;<br><span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">dispaly</span><span class="hljs-params">(T t)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> stu&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-comment">// 普通函数 </span><br>    <span class="hljs-comment">// 该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数</span><br>    <span class="hljs-comment">// 次constexpr无效</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">myType</span> ret = <span class="hljs-built_in">dispaly</span>(stu);<br>    cout &lt;&lt; ret.name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;<br>    <span class="hljs-comment">// 常量表达式函数</span><br>    <span class="hljs-comment">// 模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> ret1 = <span class="hljs-built_in">dispaly</span>(<span class="hljs-number">10</span>);<br>    cout &lt;&lt; ret1 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11-constepxr和const的区别">C++11 constepxr和const的区别</h2>
<p>先看一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis_1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-comment">//错误，x是只读的变量</span><br>    array &lt;<span class="hljs-type">int</span>,x&gt; myarr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout &lt;&lt; myarr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dis_2</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    array &lt;<span class="hljs-type">int</span>,x&gt; myarr&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout &lt;&lt; myarr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">dis_1</span>(<span class="hljs-number">5</span>);<br>   <span class="hljs-built_in">dis_2</span>();<br>&#125;<br><br><span class="hljs-comment">// dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器</span><br><br><span class="hljs-comment">// dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器</span><br></code></pre></td></tr></table></figure>
<p>C++11标准中, 为了解决const关键字的双重语义问题, 保留const表示&quot;只读&quot;的语义, 而将&quot;常量&quot;的语义划分给了新添加的constexpr关键字.</p>
<p>即凡是表达&quot;只读&quot;语义的场景都使用const, 表达&quot;常量&quot;语义的场景都使用constexpr</p>
<p>&quot;只读&quot;并不意味着其不能被修改, 例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; con_b = a;<br>    cout &lt;&lt; con_b &lt;&lt; endl;<br>    a = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; con_b &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 20</span><br><br><span class="hljs-comment">// 程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11-long-long超长整形">C++11 long long超长整形</h2>
<p><img src="%E9%95%BF%E6%95%B4%E5%9E%8B.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="长整型" /></p>
<p>可以使用<climits>头文件中与long long整形相关的3个宏, 分别是LLONG_MIN, LLONG_MAX和ULLONG_MIN</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt;<span class="hljs-string">&quot;long long最大值：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    cout &lt;&lt; dec &lt;&lt;<span class="hljs-string">&quot;long long最小值：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    cout &lt;&lt; dec &lt;&lt; <span class="hljs-string">&quot;unsigned long long最大值：&quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11右值引用">C++11右值引用</h2>
<p>基于右值引用能够引申出2种编程技巧, 分别为移动语义和完美转发</p>
<p>什么为右值:</p>
<p>左值的英文单词为&quot;locator value&quot;(lvalue)意为存储在内存中, 有明确存储地址(可寻址)的数据, 而右值则为&quot;read value&quot;(rvalue),指的是那些可以提供数据值的数据(不一定可以寻址, 例如存储在寄存器中的数据)</p>
<ol>
<li>可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-number">5</span> = a; <span class="hljs-comment">//错误，5 不能为左值</span><br><br><span class="hljs-comment">// C++ 中的左值也可以当做右值使用</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>; <span class="hljs-comment">// b 是一个左值</span><br>a = b; <span class="hljs-comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p><strong>右值引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span><br><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。对于纯右值和将亡值，都属于右值.</p>
<p><strong>C++11****移动语义</strong></p>
<p>在C++11标准之前, 如果想用其他对象初始化一个同类的新对象, 只能借助类中的复制(拷贝)构造函数, 为新对象复制一份和其他对象一模一样的数据</p>
<p>需要注意的是, 当类中<strong>拥有指针类型的成员变量时, 拷贝构造函数中需要以深拷贝(而非浅拷贝)的方式复制该指针成员</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">#include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br><span class="hljs-attr">public</span>:<br>   <span class="hljs-title function_">demo</span>():<span class="hljs-title function_">num</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> int(<span class="hljs-number">0</span>)</span>)&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;construct!&quot;</span>&lt;&lt;endl;<br>   &#125;<br>   <span class="hljs-comment">//拷贝构造函数</span><br>   <span class="hljs-title function_">demo</span>(<span class="hljs-keyword">const</span> demo &amp;d):<span class="hljs-title function_">num</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> int(*d.num)</span>)&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;copy construct!&quot;</span>&lt;&lt;endl;<br>   &#125;<br>   ~<span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;class destruct!&quot;</span>&lt;&lt;endl;<br>   &#125;<br><span class="hljs-attr">private</span>:<br>   int *num;  <span class="hljs-comment">// 指针类型的成员变量 需要深拷贝</span><br>&#125;;<br>demo <span class="hljs-title function_">get_demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">demo</span>();<br>&#125;<br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    demo a = <span class="hljs-title function_">get_demo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</span><br><br>construct! &lt;-- 执行 demo()<br>copy construct! &lt;-- 执行 return demo()<br>class destruct! &lt;-- 销毁 demo() 产生的匿名对象<br>copy construct! &lt;-- 执行 a = get_demo()<br>class destruct! &lt;-- 销毁 get_demo() 返回的临时对象<br>class destruct! &lt;-- 销毁 a<br></code></pre></td></tr></table></figure>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率</p>
<p>当类中包含指针类型的成员变量, 使用其它对象来初始化同类对象时, C++11通过右值引用,借助它实现移动语义, 避免深拷贝导致的效率问题</p>
<p>**C++**<strong>移动构造函数</strong></p>
<p>所谓移动语义, 指的是以移动而非深拷贝的方式初始化含有指针成员的类对象, 移动语义就是将其他对象拥有的内部资源&quot;移为己用&quot;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">#include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span>&#123;<br><span class="hljs-attr">public</span>:<br>    <span class="hljs-title function_">demo</span>():<span class="hljs-title function_">num</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> int(<span class="hljs-number">0</span>)</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-title function_">demo</span>(<span class="hljs-keyword">const</span> demo &amp;d):<span class="hljs-title function_">num</span>(<span class="hljs-params"><span class="hljs-keyword">new</span> int(*d.num)</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;copy construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//添加移动构造函数</span><br>    <span class="hljs-title function_">demo</span>(demo &amp;&amp;d):<span class="hljs-title function_">num</span>(<span class="hljs-params">d.num</span>)&#123;<br>        d.<span class="hljs-property">num</span> = <span class="hljs-variable constant_">NULL</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;move construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;class destruct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-attr">private</span>:<br>    int *num;<br>&#125;;<br>demo <span class="hljs-title function_">get_demo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">demo</span>();<br>&#125;<br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    demo a = <span class="hljs-title function_">get_demo</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 添加了移动构造函数: 并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生</span><br></code></pre></td></tr></table></figure>
<p>如果使用左值初始化同类对象, 同时也需要调用移动构造函数, 如何实现, 使用std::move()将左值强制转换成对应的右值, 由此便可以实现移动构造函数</p>
<p><strong>std::move()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">movedemo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">movedemo</span>():<span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">movedemo</span>(<span class="hljs-type">const</span> movedemo &amp;d):<span class="hljs-built_in">num</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*d.num))&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;copy construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//移动构造函数</span><br>    <span class="hljs-built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="hljs-built_in">num</span>(d.num)&#123;<br>        d.num = <span class="hljs-literal">NULL</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;move construct!&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-keyword">public</span>:     <span class="hljs-comment">//这里应该是 private，使用 public 是为了更方便说明问题</span><br>    <span class="hljs-type">int</span> *num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    movedemo demo;<br>    cout &lt;&lt; <span class="hljs-string">&quot;demo2:\n&quot;</span>;<br>    movedemo demo2 = demo;<br>    <span class="hljs-comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;demo3:\n&quot;</span>;<br>    movedemo demo3 = std::<span class="hljs-built_in">move</span>(demo);<br>    <span class="hljs-comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span><br>    <span class="hljs-comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数</span><br><span class="hljs-comment">// 通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11引用限定符">C++11引用限定符</h2>
<p>默认情况下, 对于类中用public修饰的成员函数, 既可以被左值对象调用, 也可以被右值对象调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">num</span>(num)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">demo <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; a.<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">move</span>(a).<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">num</span>(num)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span>&amp;</span>&#123;  <span class="hljs-comment">// 限制调用该函数的对象必须是左值对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">demo <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    cout &lt;&lt; a.<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;          <span class="hljs-comment">// 正确</span><br>    <span class="hljs-comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">int</span> num):<span class="hljs-built_in">num</span>(num)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span>&amp;&amp;</span>&#123;  <span class="hljs-comment">// 限定调用该函数的对象必须是一个右值对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">demo <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span><br>    cout &lt;&lt; <span class="hljs-built_in">move</span>(a).<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;  <span class="hljs-comment">// 正确</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Const和引用限定符</strong></p>
<p>C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">demo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">demo</span>(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> num2) :<span class="hljs-built_in">num</span>(num),<span class="hljs-built_in">num2</span>(num2) &#123;&#125;<br>    <span class="hljs-comment">//左值和右值对象都可以调用</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num;<br>    &#125;<br>    <span class="hljs-comment">//仅供右值对象调用</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_num2</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp; </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;num2;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> num2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">demo <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)</span></span>;<br>    cout &lt;&lt; a.<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;        <span class="hljs-comment">// 正确</span><br>    cout &lt;&lt; <span class="hljs-built_in">move</span>(a).<span class="hljs-built_in">get_num</span>() &lt;&lt; endl;  <span class="hljs-comment">// 正确</span><br>   <br>    <span class="hljs-comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span><br>    cout &lt;&lt; <span class="hljs-built_in">move</span>(a).<span class="hljs-built_in">get_num2</span>() &lt;&lt; endl; <span class="hljs-comment">// 正确</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-11完美转发">C++11完美转发</h2>
<p>完美转发: 函数模板可以将自己的参数&quot;完美&quot;地转发给内部调用的其他函数, 所谓完美, 即不仅仅能准确地转发参数的值, 还能保证被转发参数的左, 右值属性不变.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-built_in">otherdef</span>(t);<br>&#125;<br><br><span class="hljs-comment">// 完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</span><br><br><span class="hljs-comment">// 显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</span><br></code></pre></td></tr></table></figure>
<p>在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>&#123;<br>    <span class="hljs-built_in">otherdef</span>(t);<br>&#125;<br><span class="hljs-comment">// T&amp;&amp; 会发生引用折叠 只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值</span><br></code></pre></td></tr></table></figure>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>通过forward()函数, 可以解决上述问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//重载被调用函数，查看完美转发的效果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">otherdef</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp; t)</span> </span>&#123; <span class="hljs-comment">// 非const 引用只能接受左值 无法接受右值</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">otherdef</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; t)</span> </span>&#123; <span class="hljs-comment">// const引用 既可以接受左值 又可以接受右值</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-comment">//实现完美转发的函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(T&amp;&amp; t)</span> </span>&#123;<br>    <span class="hljs-built_in">otherdef</span>(forward&lt;T&gt;(t));  <span class="hljs-comment">// forward()函数模板用于修饰被调用函数中需要维持参数左,右值属性的参数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">function</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">int</span>  x = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">function</span>(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//程序执行结果为：</span><br>rvalue<br>lvalue<br></code></pre></td></tr></table></figure>
<h2 id="C-11-nullptr-初始化空指针">C++11 nullptr: 初始化空指针</h2>
<p>野指针(悬挂指针): 没有明确指向的指针, 为了避免野指针, 就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针.</p>
<p>使用NULL会出现以下问题:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isnull</span><span class="hljs-params">(<span class="hljs-type">void</span> *c)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;void*c&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">isnull</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int n&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">isnull</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">isnull</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 都是输出的int n</span><br><span class="hljs-comment">// 如果想令isnull(NULL)实际调用的是isnull(void* c),就需要对NULL(或者0)进行强制类型转换</span><br><span class="hljs-comment">// isnull((void*)NULL);   isnull((void*)0);</span><br></code></pre></td></tr></table></figure>
<p>C++11引入nullptr</p>
<p>nullptr是nullptr_t类型的右值常量, 专用于初始化空类型指针, nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">nullptr_t</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>
<p>不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> * a1 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">char</span> * a2 = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">double</span> * a3 = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>
<h2 id="C-11-shared-ptr智能指针">C++11 shared_ptr智能指针</h2>
<p>在实际的C++开发中, 常常会遇到由于内存资源管理不当引起的问题:</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>在C++98标准中, 支持使用auto_ptr智能指针来实现堆内存的自动回收, 但是auto_ptr存在如下的一些问题:</p>
<ol>
<li>当一个<code>auto_ptr</code>对象被复制或赋值给另一个<code>auto_ptr</code>时，它所拥有的资源（内存指针）的所有权会“转移”给新的<code>auto_ptr</code>对象，而原来的<code>auto_ptr</code>则会变为空指针.</li>
<li>由于<code>auto_ptr</code>的复制语义会导致所有权转移，它无法安全地存储在C++的标准容器中, 例如vector扩容时, 内部如果存储的是auto_ptr, 这些操作会导致元素的所有权被意外转移, 破坏容器的内部状态, 最终导致程序崩溃.</li>
<li><code>auto_ptr</code>在析构时内部使用的是<code>delete</code>，而不是<code>delete[]</code>。这意味着它不能正确地管理动态分配的数组，如果用<code>auto_ptr</code>来管理数组指针，会导致资源泄漏</li>
</ol>
<p>C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收</p>
<p><strong>shared_ptr<strong><strong>智能指针</strong></strong>的创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 包含头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1; <br><span class="hljs-comment">// 不传入任何实参std::shared_ptr&lt;int&gt; p2(nullptr);    </span><br><span class="hljs-comment">// 传入空指针 nullptr</span><br><span class="hljs-comment">// 空的shared_ptr, 其初始引用计数为0, 而不是1</span><br><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br><span class="hljs-comment">// 成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间</span><br><br>std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 使用make_shared函数创建, 和上述创建的p3是完全相同的</span><br></code></pre></td></tr></table></figure>
<p>拷贝构造和移动构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//调用拷贝构造函数</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p4</span><span class="hljs-params">(p3)</span></span>;<span class="hljs-comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span><br><span class="hljs-comment">//调用移动构造函数</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(std::move(p4))</span></span>; <span class="hljs-comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span><br></code></pre></td></tr></table></figure>
<p>P3, P4都是shared_ptr类型的智能指针, 可以用P3来初始化P4, 由于P3是左值, 因此会调用拷贝构造函数, 如果P3是空智能指针, 则P4也为空智能指针, 起引用计数为0; 反之, 则表明P4和P3指向同一块堆内存, 同时该堆内存空间的引用计数会加1.</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常</span><br><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(ptr)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(ptr)</span></span>;<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>
<p>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则</p>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//指定 default_delete 作为释放规则</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], std::default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;<br><span class="hljs-comment">//自定义释放规则</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteInt</span><span class="hljs-params">(<span class="hljs-type">int</span>*p)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span> []p;<br>&#125;<br><span class="hljs-comment">//初始化智能指针，并自定义释放规则</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], deleteInt)</span></span>;<br></code></pre></td></tr></table></figure>
<p>借助lambda表达式, 还可以更简便的初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p7</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[]p; &#125;)</span></span>;<br></code></pre></td></tr></table></figure>
<p>shared_ptr模板类提供的成员方法</p>
<p><img src="sharedptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="sharedptr模板类成员方法" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//构建 2 个智能指针</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>    <span class="hljs-comment">//输出 p2 指向的数据</span><br>    cout &lt;&lt; *p2 &lt;&lt; endl;<br>    p<span class="hljs-number">1.</span><span class="hljs-built_in">reset</span>();<span class="hljs-comment">//引用计数减 1,p1为空指针</span><br>    <span class="hljs-keyword">if</span> (p1) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p1 为空&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//以上操作，并不会影响 p2</span><br>    cout &lt;&lt; *p2 &lt;&lt; endl;<br>    <span class="hljs-comment">//判断当前和 p2 同指向的智能指针有多少个</span><br>    cout &lt;&lt; p<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// p1 为空</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11-unique-ptr智能指针">C++11 unique_ptr智能指针</h2>
<p>unique_ptr指针指向的堆内存无法同其它unique_ptr共享, 也就是说, 每个unique_ptr指针都独自拥有对其所指堆内存空间的所有权</p>
<p>也就是每个unique_ptr指针指向的堆内存空间的引用计数, 都只能为1, 一旦该unique_ptr指针放弃对所指堆内存空间的所有权, 该空间会被立刻释放回收.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;<br><br><span class="hljs-comment">// 创建unique_ptr指针的同时, 也可以明确其指向</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-comment">// C++11 标准中并没有为 unique_ptr 类型指针添加类似make_shared的模板函数</span><br><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(p4)</span></span>;<span class="hljs-comment">//错误，堆内存不共享</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(std::move(p4))</span></span>;<span class="hljs-comment">//正确，调用移动构造函数</span><br><br><br><span class="hljs-comment">// 在unique_ptr的模板实现中</span><br><span class="hljs-comment">// 拷贝构造和拷贝赋值被禁用(=delete)</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ... 其他成员 ...</span><br><br>    <span class="hljs-comment">// 拷贝构造函数被删除</span><br>    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// 拷贝赋值运算符被删除</span><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; other) <span class="hljs-keyword">noexcept</span>;<br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; other) <span class="hljs-keyword">noexcept</span>;<br>&#125;;<br><br><span class="hljs-comment">// unique_ptr 指针采用 std::default_delete 方法释放堆内存</span><br><span class="hljs-comment">// 和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式</span><br><span class="hljs-comment">// 自定义的释放规则</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myDel</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span> </span>&#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br>&#125;;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, myDel&gt; <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span><br></code></pre></td></tr></table></figure>
<p><strong>=delete关键字,</strong> <strong>C++11****引入明确的禁用一个函数, 任何试图调用该函数的代码都会导致编译时错误:</strong></p>
<ol>
<li>禁用类的特殊成员函数(例如上面的unique_ptr禁止拷贝赋值和拷贝构造)</li>
<li>阻止不期望的类型转换, 类的构造函数可能会导致不期望的隐式类型转换</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNumber</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyNumber</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">m_value</span>(value) &#123;&#125;<br>    <span class="hljs-built_in">MyNumber</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">m_value</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(value)) &#123;&#125;<br><br>    <span class="hljs-comment">// 我不希望 bool 类型被隐式转换为 int(0 或 1)</span><br>    <span class="hljs-comment">// 所以我明确地禁用接受 bool 的构造函数</span><br>    <span class="hljs-built_in">MyNumber</span>(<span class="hljs-type">bool</span>) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_value;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyNumber <span class="hljs-title">n1</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;     <span class="hljs-comment">// OK</span><br>    <span class="hljs-function">MyNumber <span class="hljs-title">n2</span><span class="hljs-params">(<span class="hljs-number">45.6</span>)</span></span>;    <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// MyNumber n3 = true;  // 编译错误！试图调用被删除的构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>禁用特定的模板实例化</li>
</ol>
<p>当你有一个函数模板时，你可能希望它适用于大多数类型，但对某些特定类型（如 <code>void*</code> 或 <code>char*</code>）禁用，因为它们可能导致不安全的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Processing value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 为 char* 类型创建一个特化版本，并将其删除</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>&lt;<span class="hljs-type">char</span>*&gt;(<span class="hljs-type">char</span>* value) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">// 为 const char* 类型创建一个特化版本，并将其删除</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">process</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">10</span>);          <span class="hljs-comment">// OK</span><br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3.14</span>);        <span class="hljs-comment">// OK</span><br>    std::string s = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">process</span>(s);           <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// process(&quot;world&quot;);     // 编译错误！模板实例化匹配到被删除的函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>unique_ptr模板类提供的成员方法</strong></p>
<p><img src="unique_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="unique_ptr模板类成员方法" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br>    *p5 = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// p 接收 p5 释放的堆内存</span><br>    <span class="hljs-type">int</span> * p = p<span class="hljs-number">5.</span><span class="hljs-built_in">release</span>();<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>    <span class="hljs-comment">//判断 p5 是否为空指针</span><br>    <span class="hljs-keyword">if</span> (p5) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p6;<br>    <span class="hljs-comment">//p6 获取 p 的所有权</span><br>    p<span class="hljs-number">6.</span><span class="hljs-built_in">reset</span>(p);<br>    cout &lt;&lt; *p6 &lt;&lt; endl;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// 10</span><br><span class="hljs-comment">// p5 is nullptr</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
<h2 id="C-11-weak-ptr智能指针">C++11 weak_ptr智能指针</h2>
<p>C++11标准虽然将weak_ptr定位为智能指针的一种, 但是该类型指针通常不单独使用(没有实际的用处), 只能和shared_ptr类型指针单独搭配使用, 可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针, 可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等.</p>
<p>当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数.</p>
<p><strong>weak_ptr 模板类中没有重载 * 和 -&gt; 运算符</strong>，这也就意味着，<strong>weak_ptr 类型指针只能访问所指的****堆内存</strong>，而无法修改它.</p>
<p><strong>weak_ptr指针的创建</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; wp1; <span class="hljs-comment">// 创建一个空weak_ptr指针</span><br><span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp2</span> <span class="hljs-params">(wp1)</span></span>; <span class="hljs-comment">// 凭借已有的weak_ptr指针, 创建一个新的weak_ptr</span><br><span class="hljs-comment">// 若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）</span><br><br><span class="hljs-comment">// weak_ptr指针更常用于指向某一个shared_ptr指针拥有的堆内存</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp3</span> <span class="hljs-params">(sp)</span></span>; <span class="hljs-comment">// wp3 指针和 sp 指针有相同的指针</span><br></code></pre></td></tr></table></figure>
<p><strong>weak_ptr模板类提供的成员方法</strong></p>
<p><img src="weak_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="weak_ptr模板类成员方法" /></p>
<p>再次强调，weak_ptr 模板类没有重载 * 和 -&gt; 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">(sp1)</span></span>;<br>    <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sp2)</span></span>;<br>    <span class="hljs-comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span><br>    cout &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//释放 sp2</span><br>    sp<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>();<br>    cout &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>    <span class="hljs-comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span><br>    cout &lt;&lt; *(wp.<span class="hljs-built_in">lock</span>()) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
<h1>C++14新特性</h1>
<p><img src="C++%E6%96%B0%E7%89%B9%E6%80%A7%E6%AF%94%E8%BE%83.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="C++新特性比较" /></p>
<h2 id="C-14-函数返回值类型推导">C++14 函数返回值类型推导</h2>
<p>C++14支持 对返回类型使用auto推导, 支持对函数和模板</p>
<p><strong>函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">4</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>模板:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(T t)</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">4</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">3.4</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是:</p>
<ol>
<li>函数内如果有多个return语句，它们必须返回相同的类型，否则编译失败</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2.3</span>; <span class="hljs-comment">// error</span><br>&#125;<br><span class="hljs-comment">// inconsistent deduction for auto return type: ‘int’ and then ‘double’</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>如果return语句返回初始化列表，返回值类型推导也会失败</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// error returning initializer list</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>如果函数是虚函数，不能使用返回值类型推导</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// error: virtual function cannot have deduced return type</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;               <span class="hljs-comment">// declared, not yet defined</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125; <span class="hljs-comment">// defined, return type is int</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li>返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL">auto <span class="hljs-built_in">sum</span>(<span class="hljs-type">int</span> i) &#123;<br>    if (i <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> i;              <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-type">int</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(i <span class="hljs-operator">-</span> <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> i; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> ok<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-lambda参数auto">C++14 lambda参数auto</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在C++11中，lambda表达式参数需要使用具体的类型声明</span><br><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> a; &#125;<br><br><span class="hljs-comment">// 在C++14中，对此进行优化，lambda表达式参数可以直接是auto</span><br><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-keyword">auto</span> a) &#123; <span class="hljs-keyword">return</span> a; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">2.3f</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-变量模板">C++14 变量模板</h2>
<p>对一个变量可以使用模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">constexpr</span> T pi = <span class="hljs-built_in">T</span>(<span class="hljs-number">3.1415926535897932385L</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; pi&lt;<span class="hljs-type">int</span>&gt; &lt;&lt; endl; <span class="hljs-comment">// 3</span><br>    cout &lt;&lt; pi&lt;<span class="hljs-type">double</span>&gt; &lt;&lt; endl; <span class="hljs-comment">// 3.14159</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-别名模板">C++14 别名模板</h2>
<p>C++14支持别名模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    T t;<br>    U u;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> B = A&lt;T, <span class="hljs-type">int</span>&gt;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B&lt;<span class="hljs-type">double</span>&gt; b;<br>    b.t = <span class="hljs-number">10</span>;<br>    b.u = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; b.t &lt;&lt; endl;<br>    cout &lt;&lt; b.u &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-constexpr限制">C++14 constexpr限制</h2>
<p>C++14相较于C++11对constexpr减少了一些限制:</p>
<ol>
<li>C++11中constexpr可以使用递归, 在C++14中可以使用局部变量和循环</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-comment">// C++14 和 C++11均可</span><br>    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (n * <span class="hljs-built_in">factorial</span>(n - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C++14中可以这么做:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-comment">// C++11中不可，C++14中可以</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        ret += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>C++11中constexpr函数必须将所有的东西放在一个单独的return语句中, 而constexpr则无此限制:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> </span>&#123; <span class="hljs-comment">// C++14 和 C++11均可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在C++14中可以这样做:</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">bool</span> flag)</span> </span>&#123; <span class="hljs-comment">// C++11中不可，C++14中可以</span><br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-deprecated-标记">C++14 [[deprecated]]标记</h2>
<p>C++ 14增加了deprecated标记, 修饰类, 函数等, 当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> [[deprecated]] A &#123; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 当编译时, 会出现如下警告</span><br>~/test$ g++ test.cc -std=c+<span class="hljs-number">+14</span><br>test.cc: In function ‘<span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()’:<br>test.cc:<span class="hljs-number">11</span>:<span class="hljs-number">7</span>: warning: ‘A’ is deprecated [-Wdeprecated-declarations]<br>     A a;<br>       ^<br>test.cc:<span class="hljs-number">6</span>:<span class="hljs-number">23</span>: note: declared here<br> <span class="hljs-keyword">struct</span> [[deprecated]] A &#123;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-二进制字面量和整形字面量分隔符">C++14 二进制字面量和整形字面量分隔符</h2>
<p>C++14引入二进制字面量, 也引入了分割符, 仅仅是为了防止看花</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0b0001&#x27;0011&#x27;1010</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">3.14&#x27;1234&#x27;1234&#x27;1234</span>;<br></code></pre></td></tr></table></figure>
<h2 id="C-14-std-make-unique">C++14 std::make_unique</h2>
<p>C++11中只有std::make_shared, 却没有std::make_unique</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br>std::unique_ptr&lt;A&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;A&gt;();<br></code></pre></td></tr></table></figure>
<h2 id="C-14-std-shared-timed-mutex与std-shared-lock">C++14 std::shared_timed_mutex与std::shared_lock</h2>
<p>C++14 通过std::shared_timed_mutex和std::shared_lock来实现读写锁, 保证多个线程可以同时读, 但是写线程必须独立运行, 写操作不可以同时和读操作一起进行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadSafe</span> &#123;<br>    <span class="hljs-keyword">mutable</span> std::shared_timed_mutex mutex_;<br>    <span class="hljs-type">int</span> value_;<br><br>    <span class="hljs-built_in">ThreadSafe</span>() &#123;<br>        value_ = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="hljs-title">loc</span><span class="hljs-params">(mutex_)</span></span>;<br>        <span class="hljs-keyword">return</span> value_;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>        value_ += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ol>
<li><strong>允许多个读取者</strong>：多个线程可以同时调用 <code>get()</code> 方法来读取 <code>value_</code> 的值，它们之间不会相互阻塞。这在“读多写少”的场景下能极大地提高并发性能。</li>
<li><strong>只允许一个写入者</strong>：当一个线程调用 <code>increase()</code> 方法来修改 <code>value_</code> 时，它必须获得一个排他性的“写锁”。此时，其他任何线程（无论是想读还是想写）都必须等待，直到这个写操作完成。</li>
</ol>
<p>上述代码使用<code>std::shared_timed_mutex</code> 确保了并发访问的正确性, 同时<code>std::shared_timed_mutex</code> 是一个<strong>带有超时功能的读写<strong><strong>互斥锁</strong></strong>,</strong> 与普通的 <code>std::shared_mutex</code> 相比，它增加了可以指定“超时时间”的加锁方法**:**</p>
<ul>
<li><code>try_lock_for(duration)</code>: 尝试在指定的时间段内获取锁。如果成功，返回 <code>true</code>；如果超时仍未获取到，返回 <code>false</code>，线程不会一直阻塞下去。</li>
<li><code>try_lock_until(time_point)</code>: 尝试获取锁，直到指定的时间点。</li>
</ul>
<h2 id="C-14-std-integer-sequence">C++14 std::integer_sequence</h2>
<p>std::integer_sequence&lt;T, ints…&gt;是一个类模板, 本身在运行时不做任何事情, 全部意义在于编译时表示一个整数序列,</p>
<p>它的主要目的是将一个整数序列封装在一个单一的类型中, 然后可以将这个类型的对象作为函数参数传递, 从而利用模板参数推导来解开(unpack)这个序列, 进而在编译时执行各种操作.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, T... ints&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_sequence</span><span class="hljs-params">(std::integer_sequence&lt;T, ints...&gt; int_seq)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The sequence of size &quot;</span> &lt;&lt; int_seq.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>    ((std::cout &lt;&lt; ints &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>), ...);<br>    <span class="hljs-comment">// C++17 折叠表达式 (Fold Expression)</span><br>    <span class="hljs-comment">// 相当于(std::cout &lt;&lt; 9 &lt;&lt; &#x27; &#x27;), (std::cout &lt;&lt; 2 &lt;&lt; &#x27; &#x27;), (std::cout &lt;&lt; 5 &lt;&lt; &#x27; &#x27;), ...;</span><br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print_sequence</span>(std::integer_sequence&lt;<span class="hljs-type">int</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>&gt;&#123;&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出：<span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">9</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>std::integer_sequence和std::tuple的配合使用：</p>
<p><code>std::tuple</code> 的元素类型不同，大小在编译时确定。我们无法用一个简单的 <code>for</code> 循环在运行时遍历它，因为 <code>std::get&lt;I&gt;(tuple)</code> 中的 <code>I</code> 必须是一个编译期常量.</p>
<p><strong>解决方法:</strong> 通过 <code>std::make_index_sequence</code> 生成一个与元组大小相等的索引序列 (<code>0, 1, 2, ...</code>)，然后利用这个序列来访问元组的每一个元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span>... Is, <span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-comment">// 非标准模式重载</span><br><span class="hljs-comment">//auto map_filter_tuple(F f, T&amp; t) &#123;</span><br><span class="hljs-comment">//    return std::make_tuple(f(std::get&lt;Is&gt;(t))...);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">// 标准模式重载: 用户调用一个入口, 入口函数内部生成序列, 再调用实现函数</span><br><span class="hljs-comment">// S 是一个 index_sequence 类型，例如 std::make_index_sequence&lt;std::tuple_size_v&lt;T&gt;&gt;</span><br><span class="hljs-comment">// 创建一个 S 类型的临时对象 &#123;&#125;，然后调用下面的重载</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S, <span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">map_filter_tuple</span><span class="hljs-params">(F&amp;&amp; f, T&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map_filter_tuple</span>(S&#123;&#125;, std::forward&lt;F&gt;(f), t);<br>&#125;<br><br><span class="hljs-comment">// 真正干活的函数</span><br><span class="hljs-keyword">template</span> &lt;std::<span class="hljs-type">size_t</span>... Is, <span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">map_filter_tuple</span><span class="hljs-params">(std::index_sequence&lt;Is...&gt;, F f, T&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">get</span>&lt;Is&gt;(t))...);<br>&#125;<br><span class="hljs-comment">// 用户侧调用 我们相对每个元素调用一个lambda函数f</span><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, <span class="hljs-type">char</span>&gt; <span class="hljs-title">my_tuple</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br><br><span class="hljs-keyword">auto</span> new_tuple = map_filter_tuple&lt;std::make_index_sequence&lt;<span class="hljs-number">3</span>&gt;&gt;(f, my_tuple);<br><br><span class="hljs-comment">// 调用逻辑</span><br><span class="hljs-comment">// 1. map_filter_tuple&lt;S, ...&gt; 被调用</span><br><span class="hljs-comment">// 2. 创建了一个 std::make_index_sequence&lt;3&gt; 的实例，也就是 std::index_sequence&lt;0, 1, 2&gt; 类型的临时对象</span><br><span class="hljs-comment">// 3. 用了第二个重载版本：map_filter_tuple(std::index_sequence&lt;0, 1, 2&gt;&#123;&#125;, f, my_tuple)</span><br><span class="hljs-comment">// 4. Is... 被推导为 0, 1, 2</span><br><span class="hljs-comment">// 5. td::make_tuple(f(std::get&lt;Is&gt;(t))...) 在编译期展开为: std::make_tuple( f(std::get&lt;0&gt;(t)), f(std::get&lt;1&gt;(t)), f(std::get&lt;2&gt;(t)) );</span><br><span class="hljs-comment">// 6. 最终这个函数返回一个新的元组, 其中每个元素都是对应元素经过f处理后的结果</span><br></code></pre></td></tr></table></figure>
<h2 id="C-14-std-exchange">C++14 std::exchange</h2>
<p>先看实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> U </span>= T&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">exchange</span><span class="hljs-params">(T&amp; obj, U&amp;&amp; new_value)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 将 obj 的旧值移动到 old_value 中保存起来</span><br>    T old_value = std::<span class="hljs-built_in">move</span>(obj);<br>    <br>    <span class="hljs-comment">// 2. 用 new_value 为 obj 赋新值</span><br>    <span class="hljs-comment">//    std::forward 保证了如果 new_value 是右值，就移动赋值；如果是左值，就拷贝赋值</span><br>    obj = std::forward&lt;U&gt;(new_value);<br>    <br>    <span class="hljs-comment">// 3. 返回被保存的旧值</span><br>    <span class="hljs-keyword">return</span> old_value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>exchange和核心作用在于用一个新值替换对象原来的值, 并且以返回值的形式&quot;取走&quot;该对象的旧值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v; <span class="hljs-comment">// v 是一个空的 vector</span><br>    <br>    <span class="hljs-comment">// 调用 std::exchange</span><br>    std::<span class="hljs-built_in">exchange</span>(v, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;); <br>    <br>    cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出 4</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : v) &#123;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;   <span class="hljs-comment">// 输出 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>std::exchange</code> 最经典的用途是<strong>简化移动构造函数和移动<strong><strong>赋值运算符</strong></strong>的实现</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;<br>    <span class="hljs-type">char</span>* data_;<br>    <span class="hljs-type">size_t</span> size_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        data_ = other.data_;<br>        size_ = other.size_;<br>        <span class="hljs-comment">// 必须手动将被移动对象的成员重置为有效状态</span><br>        other.data_ = <span class="hljs-literal">nullptr</span>;<br>        other.size_ = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用std::exchange</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;<br>    <span class="hljs-type">char</span>* data_ = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">size_t</span> size_ = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-comment">// 一行代码完成：获取 other.data_ 的值，并将其设为 nullptr</span><br>        data_ = std::<span class="hljs-built_in">exchange</span>(other.data_, <span class="hljs-literal">nullptr</span>);<br>        size_ = std::<span class="hljs-built_in">exchange</span>(other.size_, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>和std::swap的主要区别在于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br>std::<span class="hljs-built_in">swap</span>(a, b); <span class="hljs-comment">// a is now 10, b is now 5</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> old_a = std::<span class="hljs-built_in">exchange</span>(a, b); <span class="hljs-comment">// a is now 10, b is still 10, old_a is 5</span><br></code></pre></td></tr></table></figure>
<h2 id="C-14-std-quoted">C++14 std::quoted</h2>
<p>C++14 引入std::quoted用于给字符串添加双引号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    cout &lt;&lt; std::<span class="hljs-built_in">quoted</span>(str) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>~/test$ g++ test.cc -std=c+<span class="hljs-number">+14</span><br>~/test$ ./a.out<br>hello world<br><span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
<h1>C++17新特性</h1>
<h2 id="C-17-构造函数模板推导">C++17 构造函数模板推导</h2>
<p>在C++17前构造一个模板类对象需要指明类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>)</span></span>; <span class="hljs-comment">// before c++17</span><br></code></pre></td></tr></table></figure>
<p>C++17就不需要特殊指定，直接可以推导出类型，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">pair <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>)</span></span>; <span class="hljs-comment">// c++17 自动推导</span><br>vector v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// c++17</span><br></code></pre></td></tr></table></figure>
<h2 id="C-17-结构化绑定">C++17 结构化绑定</h2>
<p>结构化绑定的语法非常直观:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> [name1, name2, ... ] = expression;<br></code></pre></td></tr></table></figure>
<p>在没有结构化绑定之前, 从一个复合对象中取出多个值通常非常繁琐</p>
<p><strong>遍历<strong><strong>std</strong></strong>::map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++17 之前</span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; word_counts;<br><span class="hljs-comment">// ... 填充 map ...</span><br><br><span class="hljs-comment">// 需要手动创建pair变量, 然后通过.first和.second分辨访问键和值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : word_counts) &#123;<br>    <span class="hljs-type">const</span> std::string&amp; word = pair.first;<br>    <span class="hljs-type">int</span> count = pair.second;<br>    std::cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>**处理<strong><strong>std</strong></strong>::**<strong>tuple</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++17 之前</span><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;hello&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">get_data</span>();<br><span class="hljs-type">int</span> id = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(t);<br><span class="hljs-type">double</span> value = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(t);<br>std::string name = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(t);<br><br><span class="hljs-comment">// 或者使用 std::tie，但需要提前声明变量</span><br><span class="hljs-type">int</span> id_tie;<br><span class="hljs-type">double</span> value_tie;<br>std::string name_tie;<br>std::<span class="hljs-built_in">tie</span>(id_tie, value_tie, name_tie) = <span class="hljs-built_in">get_data</span>();<br></code></pre></td></tr></table></figure>
<p><code>std::get&lt;index&gt;</code> 的可读性很差，<code>index</code> 必须是编译期常量，而且写错索引号是常见的错误。<code>std::tie</code> 稍微好一点，但要求你必须先声明变量，很啰嗦。</p>
<p>如果使用结构化绑定的语法糖, 就会很简便</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">// C++17</span><br>std::map&lt;std::string, <span class="hljs-type">int</span>&gt; word_counts;<br><span class="hljs-comment">// ... 填充 map ...</span><br><br><span class="hljs-comment">// 使用引用时, 还能够改变对象的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [word, count] : word_counts) &#123;<br>    <span class="hljs-comment">// word 直接绑定到 pair.first</span><br>    <span class="hljs-comment">// count 直接绑定到 pair.second</span><br>    std::cout &lt;&lt; word &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;<br>&#125;<br><br><br><span class="hljs-comment">// C++17</span><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>, std::string&gt; <span class="hljs-title">get_data</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;hello&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-keyword">auto</span> [id, value, name] = <span class="hljs-built_in">get_data</span>();<br><br><span class="hljs-comment">// id 绑定到 tuple 的第0个元素</span><br><span class="hljs-comment">// value 绑定到第1个元素</span><br><span class="hljs-comment">// name 绑定到第2个元素</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;, Name: &quot;</span> &lt;&lt; name &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
<p>需要注意的是, 结构化绑定不能应用于constexpr(在C++20中可以)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span>[x, y] = std::<span class="hljs-built_in">pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.3f</span>); <span class="hljs-comment">// compile error, C++20可以</span><br></code></pre></td></tr></table></figure>
<p>结构化绑定不止可以绑定pair和tuple, 还可以绑定数组和结构体等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-type">int</span> array[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>auto [a, b, c] = array;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-comment">// 注意这里的struct的成员一定要是public的</span><br><span class="hljs-keyword">struct</span> Point &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br>Point <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>&#125;<br><span class="hljs-keyword">const</span> auto [x, y] = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>还可以实现自定义类的结构化绑定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;<br>        name_ = <span class="hljs-string">&quot;name&quot;</span>;<br>        age_ = <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> age_; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br>    <span class="hljs-type">int</span> age_;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">size_t</span> I&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> Entry&amp; e)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(I == <span class="hljs-number">0</span>)</span> <span class="hljs-keyword">return</span> e.<span class="hljs-title">GetName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (I == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> e.<span class="hljs-built_in">GetAge</span>();<br>&#125;<br><br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="hljs-type">size_t</span>, <span class="hljs-number">2</span>&gt; &#123;&#125;;<br>    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_element</span>&lt;<span class="hljs-number">0</span>, Entry&gt; &#123; <span class="hljs-keyword">using</span> type = std::string; &#125;;<br>    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tuple_element</span>&lt;<span class="hljs-number">1</span>, Entry&gt; &#123; <span class="hljs-keyword">using</span> type = <span class="hljs-type">int</span>; &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Entry e;<br>    e.<span class="hljs-built_in">Init</span>();<br>    <span class="hljs-keyword">auto</span> [name, age] = e;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="hljs-comment">// name 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-if-switch语句初始化">C++17 if-switch语句初始化</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++17之前</span><br><span class="hljs-type">int</span> a = <span class="hljs-built_in">GetValue</span>();<br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">101</span>) &#123;<br>    cout &lt;&lt; a;<br>&#125;<br><br><span class="hljs-comment">// C++17</span><br><span class="hljs-comment">// if (init; condition)</span><br><span class="hljs-keyword">if</span> (<span class="hljs-type">int</span> a = <span class="hljs-built_in">GetValue</span>()); a &lt; <span class="hljs-number">101</span>) &#123;<br>    cout &lt;&lt; a;<br>&#125;<br><br>string str = <span class="hljs-string">&quot;Hi World&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> [pos, size] = <span class="hljs-built_in">pair</span>(str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Hi&quot;</span>), str.<span class="hljs-built_in">size</span>()); pos != string::npos) &#123;<br>    std::cout &lt;&lt; pos &lt;&lt; <span class="hljs-string">&quot; Hello, size is &quot;</span> &lt;&lt; size;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-内联变量">C++17 内联变量</h2>
<p>C++17前只有内联函数，现在有了内联变量，印象中C++类的静态成员变量在头文件中是不能初始化的 ，但是有了内联变量，就可以达到目的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// header file</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value;  <br>&#125;;<br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> A::value = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// ==========或者========</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17折叠表达式">C++17折叠表达式</h2>
<p>C++17引入折叠表达式使可变参数模板编程更加方便</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ... Ts&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(Ts ... ts)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (ts + ...);<br>&#125;<br><span class="hljs-type">int</span> a &#123;<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)&#125;; <span class="hljs-comment">// 15</span><br>std::string a&#123;<span class="hljs-string">&quot;hello &quot;</span>&#125;;<br>std::string b&#123;<span class="hljs-string">&quot;world&quot;</span>&#125;;<br>cout &lt;&lt; <span class="hljs-built_in">sum</span>(a, b) &lt;&lt; endl; <span class="hljs-comment">// hello world</span><br></code></pre></td></tr></table></figure>
<h2 id="C-17-constexpr-lambda表达式">C++17 constexpr lambda表达式</h2>
<p>C++17前lambda表达式只能在运行时使用，C++17引入constexpr lambda表达式，可以在编译期间进行计算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// c++17可编译</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> lamb = [] (<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n * n; &#125;;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">lamb</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">9</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：constexpr函数有如下限制：</p>
<p>函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。</p>
<h2 id="C-17-namepspace嵌套">C++17 namepspace嵌套</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> A &#123;<br>    <span class="hljs-keyword">namespace</span> B &#123;<br>        <span class="hljs-keyword">namespace</span> C &#123;<br>            <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// c++17，更方便更舒适</span><br><span class="hljs-keyword">namespace</span> A::B::C &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-has-include预处理表达式">C++17 __has_include预处理表达式</h2>
<p>可以判断是否有某个头文件，代码可能会在不同的编译器下工作，不同编译器的可用头文件可能不同，所以可以以此来判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined __has_include</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __has_include(<span class="hljs-string">&lt;charconv&gt;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> has_charconv 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function">std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ConvertToInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> value&#123;&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> has_charconv</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> last = str.<span class="hljs-built_in">data</span>() + str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">from_chars</span>(str.<span class="hljs-built_in">data</span>(), last, value);<br>    <span class="hljs-keyword">if</span> (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) <span class="hljs-keyword">return</span> value;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-comment">// alternative implementation...</span><br>    其它方式实现<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-在lambda表达式用-this捕获对象副本">C++17 在lambda表达式用*this捕获对象副本</h2>
<p>正常情况下，lambda表达式中访问类的对象成员变量需要捕获this，但是这里捕获的是this指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题**（悬垂引用）**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> f = [<span class="hljs-keyword">this</span>] &#123;<br>            cout &lt;&lt; a &lt;&lt; endl;<br>        &#125;;<br>        <span class="hljs-built_in">f</span>();<br>    &#125;  <br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>C++17新增新特性，捕获*this，不持有this指针，而是持有对象的拷贝，这样生命周期和对象的生命周期就不相关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> f = [*<span class="hljs-keyword">this</span>] &#123; <span class="hljs-comment">// 这里</span><br>            cout &lt;&lt; a &lt;&lt; endl;<br>        &#125;;<br>        <span class="hljs-built_in">f</span>();<br>    &#125;  <br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>    a.<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-新增Attribute">C++17 新增Attribute</h2>
<p>平时在项目中见过__declspec, <strong>attribute</strong> , #pragma指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">short</span> f[<span class="hljs-number">3</span>]; &#125; __attribute__((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">8</span>)));<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fatal</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((noreturn))</span></span>;<br></code></pre></td></tr></table></figure>
<p>在C++11和C++14中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">[[carries_dependency]] 让编译期跳过不必要的内存栅栏指令<br>[[noreturn]] 函数不会返回<br>[[deprecated]] 函数将弃用的警告<br><br>[[noreturn]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">terminate</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;use new func instead&quot;</span>)]] <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>C++17新增了三个</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// [[fallthrough]]，用在switch中提示可以直接落下去，</span><br><span class="hljs-comment">// 不需要break，让编译期忽略警告</span><br><span class="hljs-comment">// 使得编译器和其它开发者都可以理解开发者的意图</span><br><span class="hljs-keyword">switch</span> (i) &#123;&#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        xxx; <span class="hljs-comment">// warning</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        xxx; <br>        [[<span class="hljs-keyword">fallthrough</span>]];      <span class="hljs-comment">// 警告消除</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        xxx;<br>       <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// [[nodiscard]] ：表示修饰的内容不能被忽略，</span><br><span class="hljs-comment">// 可用于修饰函数，标明返回值一定要被处理</span><br>[[nodiscard]] <span class="hljs-type">int</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>;<br>void F() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// warning 没有处理函数返回值</span><br>&#125;<br><br><span class="hljs-comment">// [[maybe_unused]] ：提示编译器修饰的内容可能暂时没有使用，</span><br><span class="hljs-comment">// 避免产生警告</span><br><br>void func1() &#123;&#125;<br>[[maybe_unused]] void func2() &#123;&#125; <span class="hljs-comment">// 警告消除</span><br>void func3() &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br>    [[maybe_unused]] <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>; <span class="hljs-comment">// 警告消除</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17字符串转换">C++17字符串转换</h2>
<p>新增from_chars函数和to_chars函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> std::string str&#123;<span class="hljs-string">&quot;123456098&quot;</span>&#125;;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">from_chars</span>(str.<span class="hljs-built_in">data</span>(), str.<span class="hljs-built_in">data</span>() + <span class="hljs-number">4</span>, value);<br>    <span class="hljs-keyword">if</span> (res.ec == std::<span class="hljs-built_in">errc</span>()) &#123;<br>        cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;, distance &quot;</span> &lt;&lt; res.ptr - str.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res.ec == std::errc::invalid_argument) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;invalid&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    str = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;12.34);</span><br><span class="hljs-string">    double val = 0;</span><br><span class="hljs-string">    const auto format = std::chars_format::general;</span><br><span class="hljs-string">    res = std::from_chars(str.data(), str.data() + str.size(), value, format);</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    str = std::string(&quot;</span>xxxxxxxx<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    const int v = 1234;</span><br><span class="hljs-string">    res = std::to_chars(str.data(), str.data() + str.size(), v);</span><br><span class="hljs-string">    cout &lt;&lt; str &lt;&lt; &quot;</span>, filled <span class="hljs-string">&quot; &lt;&lt; res.ptr - str.data() &lt;&lt; &quot;</span> characters \n<span class="hljs-string">&quot;;</span><br><span class="hljs-string">    // 1234xxxx, filled 4 characters</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-variant">C++17 std::variant</h2>
<p>C++17增加std::variant实现union的功能，但却比union更高级，例如union里面不能有string这种类型，但是std::variant可以，可以支持更多复杂类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// c++17可编译</span><br>    std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-keyword">var</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">//int的index = 0， string的index = 1</span><br>    <span class="hljs-comment">//初始化 hello 首先匹配string index =  1</span><br>    cout &lt;&lt; <span class="hljs-keyword">var</span>.index() &lt;&lt; endl; <br>    <span class="hljs-keyword">var</span> = <span class="hljs-number">123</span>;<br>    <span class="hljs-comment">// int也有值了 优先输出int的index 即为 0</span><br>    cout &lt;&lt; <span class="hljs-keyword">var</span>.index() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">var</span> = <span class="hljs-string">&quot;world&quot;</span>;<br>        std::<span class="hljs-type">string</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> std::get&lt;std::string&gt;(<span class="hljs-keyword">var</span>); <span class="hljs-comment">// 通过类型获取值</span><br>        <span class="hljs-keyword">var</span> = <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> std::get&lt;<span class="hljs-number">0</span>&gt;(<span class="hljs-keyword">var</span>); <span class="hljs-comment">// 通过index获取对应值</span><br>        cout &lt;&lt; str &lt;&lt; endl;<br>        cout &lt;&lt; i &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">catch</span>(...) &#123;<br>        <span class="hljs-comment">// xxx;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <br>  <span class="hljs-comment">// 一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败</span><br>struct A &#123;<br>    A(<span class="hljs-type">int</span> i)&#123;&#125;  <br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    std::variant&lt;A, <span class="hljs-type">int</span>&gt; <span class="hljs-keyword">var</span>; <span class="hljs-comment">// 编译失败</span><br>&#125;<br><br><span class="hljs-comment">// 可以使用std::monostate来打个桩，模拟一个空状态来避免这种情况</span><br>std::variant&lt;std::monostate, A&gt; <span class="hljs-keyword">var</span>; <span class="hljs-comment">// 可以编译成功</span><br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-optional">C++17 std::optional</h2>
<p>有时候可能会有需求，让函数返回一个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><span class="hljs-function">A <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>();<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 异常情况下，怎么返回异常值呢，想返回个空呢</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 有一种办法是返回对象指针，异常情况下就可以返回nullptr啦，</span><br><span class="hljs-comment">// 但是这就涉及到了内存管理，也许你会使用智能指针，但这里其实有更方便的办法就是std::optional</span><br><br>std::optional&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">StoI</span>(<span class="hljs-type">const</span> std::string &amp;s) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(s);<br>    &#125; <span class="hljs-built_in">catch</span>(...) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string s&#123;<span class="hljs-string">&quot;123&quot;</span>&#125;;<br>    std::optional&lt;<span class="hljs-type">int</span>&gt; o = <span class="hljs-built_in">StoI</span>(s);<br>    <span class="hljs-keyword">if</span> (o) &#123;<br>        cout &lt;&lt; *o &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-any">C++17 std::any</h2>
<p>C++17引入any可以存储任何类型的单个值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Bash">int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123; // c++17可编译<br>    std::any a = 1;<br>    cout &lt;&lt; <span class="hljs-string">a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;int&gt;(a</span>) &lt;&lt; <span class="hljs-string">endl;</span><br><span class="hljs-string">    a = 2.2f;</span><br><span class="hljs-string">    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;float&gt;(a) &lt;&lt; endl</span>;<br>    <span class="hljs-keyword">if</span> (a.has_value()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">a.type().name();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    a</span>.reset();<br>    <span class="hljs-keyword">if</span> (a.has_value()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">a.type().name();</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    a</span> = std::string(<span class="hljs-string">&quot;a&quot;</span>);<br>    cout &lt;&lt; <span class="hljs-string">a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(a</span>) &lt;&lt; <span class="hljs-string">endl;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-apply">C++17 std::apply</h2>
<p>使用std::apply可以将tuple展开作为函数的参数传入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second)</span> </span>&#123; <span class="hljs-keyword">return</span> first + second; &#125;<br><br><span class="hljs-keyword">auto</span> add_lambda = [](<span class="hljs-keyword">auto</span> first, <span class="hljs-keyword">auto</span> second) &#123; <span class="hljs-keyword">return</span> first + second; &#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">apply</span>(add, std::<span class="hljs-built_in">pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(std::<span class="hljs-built_in">pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// error</span><br>    std::cout &lt;&lt; std::<span class="hljs-built_in">apply</span>(add_lambda, std::<span class="hljs-built_in">tuple</span>(<span class="hljs-number">2.0f</span>, <span class="hljs-number">3.0f</span>)) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-make-from-tuple">C++17 std::make_from_tuple</h2>
<p>使用make_from_tuple可以将tuple展开作为构造参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> first, <span class="hljs-type">float</span> second, <span class="hljs-type">int</span> third) &#123;<br>        std::cout &lt;&lt; first &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> tuple = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-number">3.14f</span>, <span class="hljs-number">0</span>);<br>   std::<span class="hljs-built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="hljs-built_in">move</span>(tuple));<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-string-view">C++17 std::string_view</h2>
<p>通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::string_view stv)</span> </span>&#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    std::cout &lt;&lt; str &lt;&lt; std::endl;<br><br>    <span class="hljs-function">std::string_view <span class="hljs-title">stv</span><span class="hljs-params">(str.c_str(), str.size())</span></span>;<br>    cout &lt;&lt; stv &lt;&lt; endl;<br>    <span class="hljs-built_in">func</span>(stv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-17-as-const">C++17 as_const</h2>
<p>C++17使用as_const可以将左值转换成const类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string str = <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">const</span> std::string&amp; constStr = std::<span class="hljs-built_in">as_const</span>(str);<br></code></pre></td></tr></table></figure>
<h2 id="C-17-file-system">C++17 file_system</h2>
<p>C++17正式将file_system纳入标准，提供关于文件的大多数功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> fs = std::filesystem;<br>fs::<span class="hljs-built_in">create_directory</span>(dir_path);<br>fs::<span class="hljs-built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing);<br>fs::<span class="hljs-built_in">exists</span>(filename);<br>fs::<span class="hljs-built_in">current_path</span>(err_code);<br></code></pre></td></tr></table></figure>
<h2 id="C-17-std-shared-mutex">C++17 std::shared_mutex</h2>
<p>C++17引入了shared_mutex, 可以实现读写锁</p>
<h1>C++20新特性</h1>
<h2 id="新增关键字">新增关键字</h2>
<ol>
<li>Concepts(模板约束), 用于定义一个模板参数必须满足一组约束(requirements), 取代了过去晦涩难懂的SFINAE和std::enable_if技术, 让模板约束变得可读,可复用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 定义一个名为 &quot;Integral&quot; 的 concept</span><br><span class="hljs-comment">// 它要求类型 T 必须是一个整数类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;<br><br><span class="hljs-comment">// 使用 concept 来约束模板参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_integer</span><span class="hljs-params">(Integral <span class="hljs-keyword">auto</span> number)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This is an integer: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 或者使用更传统的模板语法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Integral T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process_integer</span><span class="hljs-params">(T number)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>Requires : requires关键字有两种主要形式: requires子句(clause) 和 requires表达式(expression)</li>
</ol>
<p>Requires 子句: 用于将一个concept应用于模板声明, 作为其约束条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// requires 子句，跟在模板参数列表之后</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">requires</span> Integral&lt;T&gt; <span class="hljs-comment">// &lt;--- requires 子句</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_function</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Requires表达式: 用于在concept内部详细说明一个类型必须满足的语法要求, 例如它必须满足某个成员函数, 某个表达式必须能够编译等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) &#123; <span class="hljs-comment">// &lt;--- requires 表达式</span><br>    &#123; a + b &#125; -&gt; std::same_as&lt;T&gt;; <span class="hljs-comment">// 要求 a+b 必须能编译，且结果类型与 T 相同</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Addable T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>consteval和constinit : 进一步强化了C++的编程能力, 提供了比constexpr更严格的保证</li>
</ol>
<p>Consteval : 声明一个立即函数, 立即函数必须在编译期产生一个常量结果, 任何试图在运行时调用consteval函数都会导致编译错误.</p>
<p>与constexpr的区别: constexpr函数可以在编译期运行, 但如果参数不是常量, 它也可以在运行时运行. consteval则强制函数只能在编译期运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> compile_time_sq = <span class="hljs-built_in">square</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// OK，编译期求值</span><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// int runtime_sq = square(x); // 编译错误！x 不是常量，无法在编译期求值</span><br></code></pre></td></tr></table></figure>
<p>Constinit: 断言一个具有静态或线程存储期的变量(即全局变量, 静态变量)必须进行静态初始化(即零初始化或常量初始化)</p>
<p>目的: 解决**“静态初始化顺序惨案”(静态变量在函数执行时会进行初始化, 如果不同文件中的静态变量都要进行初始化, 且存在相互依赖关系, 初始化顺序不定会导致失败),** constinit保证变量的初始化是在编译期或加载时完成的, 不涉及任何运行时的动态执行代码, 从而避免了不同编译单元中静态变量初始化的依赖问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; &#125;<br><br><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> my_global = <span class="hljs-built_in">get_val</span>(); <span class="hljs-comment">// OK，保证静态初始化</span><br><br><span class="hljs-comment">// constinit int another_global = time(nullptr); // 编译错误！time() 不是常量表达式</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li>Coroutines (协程): co_await, co_return, co_yield</li>
</ol>
<p>co_await: 协程的<strong>暂停点</strong>, 用于等待一个异步操作完成, 当协程co_await一个对象时, 它会暂停自身的执行, 并将控制权交还给调用者或者事件循环, 直到等待的操作完成, 协程才会从暂停点恢复执行, 这个过程不会阻塞线程.</p>
<p>co_return: 用于从协程中返回最终结果, 它类似于普通函数中的return, 但它标志着协程的执行完成, 并将结果传递给等待它的future或promise对象.</p>
<p>co_yield: 用于产生一个值并暂停协程, 主要用于实现<strong>生成器(Generator),</strong> 当外部代码从生成器中请求一个值时, 协程会执行到co_yield, 产出该值, 然后暂停, 下次请求时, 它会从上次暂停的地方继续执行.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">// 异步任务</span><br><span class="hljs-function">Task&lt;std::string&gt; <span class="hljs-title">read_file_async</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> file = <span class="hljs-keyword">co_await</span> <span class="hljs-built_in">open_file_handle</span>(path); <span class="hljs-comment">// 暂停，等待文件打开</span><br>    <span class="hljs-keyword">auto</span> content = <span class="hljs-keyword">co_await</span> file.<span class="hljs-built_in">read_all</span>();   <span class="hljs-comment">// 暂停，等待读取完成</span><br>    <span class="hljs-keyword">co_return</span> content;                         <span class="hljs-comment">// 返回最终结果</span><br>&#125;<br><br><span class="hljs-comment">// 生成器</span><br><span class="hljs-function">Generator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count_to</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">co_yield</span> i; <span class="hljs-comment">// 产出一个值并暂停</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li>新的基本类型: char8_t</li>
</ol>
<p>引入一个新的<strong>基本字符类型,</strong> 专门用于表示和存储<strong>UTF-8</strong>编码的字符.</p>
<p>解决长期以来的一个类型安全问题, 在C++20之前, UTF-8字符串字面量是const char*, 这使得它与普通的ASCII或其他编码的char 数据无法区分, 容易导致编码错误. char8_t在系统类型中明确了其编码为UTF-8.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++20: u8 字符串字面量的类型是 const char8_t*</span><br><span class="hljs-type">const</span> <span class="hljs-type">char8_t</span>* utf8_str = <span class="hljs-string">u8&quot;你好, C++20!&quot;</span>;<br><br><span class="hljs-comment">// 标准库也提供了对应的字符串类型</span><br>std::u8string my_u8_string = <span class="hljs-string">u8&quot;This is a UTF-8 string.&quot;</span>;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-模块-Modules">C++20 模块(Modules)</h2>
<p>C++20 引入像Python一样模板的概念, 通过export导出, import导入, 模块具备以下的优点:</p>
<ul>
<li>没有头文件</li>
<li>声明实现仍然可分离, 但非必要</li>
<li>可以<strong>显式</strong>指定那些导出(类, 函数等)</li>
<li>不需要头文件重复引入宏 (include guards)</li>
<li>模块之间名称可以相同不会冲突</li>
<li>模块只处理一次, 编译更快 (<em>头文件每次引入都需要处理</em>)</li>
<li>预处理宏只在模块内有效</li>
<li>模块引入顺序无关紧要</li>
</ul>
<p><strong>创建模块:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// cppcon.cpp </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> cppcon; <br><span class="hljs-keyword">namespace</span> CppCon &#123; <br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">GetWelcomeHelper</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Welcome to CppCon 2019!&quot;</span>;  &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">GetWelcome</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetWelcomeHelper</span>();&#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>引用模块:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// main.cpp </span><br><span class="hljs-keyword">import</span> cppcon; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    std::cout &lt;&lt; CppCon::<span class="hljs-built_in">GetWelcome</span>(); <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-import-头文件">C++20 import 头文件</h2>
<p>传统的#include是一个非常古老且简单的文本替换机制, 当你写 <code>#include &quot;myheader.h&quot;</code> 时，预处理器会找到 <code>myheader.h</code> 这个文件，把它里面的<strong>全部文本内容</strong>原封不动地复制粘贴到你写 <code>#include</code> 的地方, 这会带来几个问题:</p>
<ol>
<li><strong>重复解析</strong>：如果 100 个 <code>.cpp</code> 文件都 <code>#include &lt;vector&gt;</code>，那么编译器就需要完整地解析和编译 <code>&lt;vector&gt;</code> 的全部源代码 100 次。对于大型项目，这种重复劳动会消耗掉大量的编译时间.</li>
<li><strong>缺乏封装</strong>：头文件必须暴露所有的实现细节，包括私有成员变量、内部使用的辅助函数等。这破坏了封装性，使得 API 接口非常不清晰.</li>
<li><strong>脆弱性****与宏污染 (<strong>Macro Pollution)</strong>：<code>#include</code> 的内容会受到它被包含位置</strong>之前<strong>定义的宏的影响。比如，在 <code>#include &lt;windows.h&gt;</code> 之前 <code>#define max ...</code>，就可能导致 <code>windows.h</code> 内部编译失败, 反之，一个头文件定义的宏会“泄露”出来，影响到</strong>之后**的所有代码。<code>windows.h</code> 定义了 <code>max</code> 宏，这经常与 <code>std::max</code> 发生冲突，是 C++ 程序员的噩梦.</li>
</ol>
<p><strong>C++20 通过import头文件:</strong></p>
<ul>
<li>隐式地将 <code>iostream</code> 转换为模块</li>
<li>加速构建, 因为 iostream 只会处理一次</li>
<li>和预编译头 (PCH) 具有相似的效果</li>
</ul>
<p><strong>传统方式(#include):</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// math.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-comment">// math.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>**C++**<strong>20 模块方式(import):</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// math.cppm (模块接口文件)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> math; <span class="hljs-comment">// 声明一个名为 math 的模块</span><br><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-comment">// 导出这个函数</span><br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-keyword">import</span> &lt;iostream&gt;; <span class="hljs-comment">// 标准库头文件也可以被导入为模块（需要编译器支持）</span><br><span class="hljs-keyword">import</span> math;      <span class="hljs-comment">// 导入我们自己定义的 math 模块</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-Ranges">C++20 Ranges</h2>
<p>Range的核心作用是<strong>从根本上简化和增强我们与元素序列(如容器, 数组等)交互的方式, 使代码更具可读性, 组合性和安全性.</strong></p>
<ol>
<li><strong>Range(范围)</strong> : 一个Range是一个单一的对象, 它封装了一个可以迭代的元素序列的概念, 简单来说, 任何拥有begin()和end()的东西(如std::vector, std::string)就是一个Range.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++17</span><br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-comment">// C++20</span><br>std::ranges::<span class="hljs-built_in">sort</span>(v); <span class="hljs-comment">// 代码更简洁，更安全</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>Views(视图)-Ranges:</strong> 一个View是一个轻量级的, **非拥有(non-owning)**的Range, 它是对另一个Range的一种&quot;视角&quot;或&quot;适配器&quot;.</li>
</ol>
<ul>
<li><strong>懒加载 (<strong><strong>Lazy Evaluation</strong></strong>)</strong>：View 的操作（如筛选、转换）不会立即执行。它们只在当您真正需要访问元素时才进行计算。</li>
<li><strong>可组合 (Composable)</strong>：这是最具革命性的特性。你可以使用 <strong>管道操作符</strong> <strong><code>|</code></strong> 将多个 View 串联起来，形成一个处理流水线。</li>
<li><strong>高效</strong>：由于是懒加载且不拥有数据，View 的创建和组合几乎没有运行时开销，也<strong>不需要中间临时容器</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br><br><span class="hljs-comment">// 定义转换操作</span><br><span class="hljs-keyword">auto</span> even = [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">auto</span> square = [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n * n; &#125;;<br><br><span class="hljs-comment">// C++20 Ranges 的做法</span><br><span class="hljs-keyword">auto</span> result_view = numbers | std::views::<span class="hljs-built_in">filter</span>(even)   <span class="hljs-comment">// 筛选出偶数</span><br>                           | std::views::<span class="hljs-built_in">transform</span>(square) <span class="hljs-comment">// 将它们平方</span><br>                           | std::views::<span class="hljs-built_in">take</span>(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 取前5个</span><br><br><span class="hljs-comment">// result_view 此时只是一个“计算配方”，没有进行任何实际计算</span><br><span class="hljs-comment">// 当我们遍历它时，计算才会发生</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : result_view) &#123;<br>    std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 4 16 36 64 100</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>更多的例子:</p>
<p><strong>串联actions: 排序然后去重, 操作会原地对data进行更改, 然后返回</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; data&#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>&#125;; <br>vector&lt;<span class="hljs-type">int</span>&gt; result = data | actions::sort | actions::unique;<br></code></pre></td></tr></table></figure>
<p><strong>过滤和变换: view::int(1)产生一个无限的整数序列, 平方, 取前10个元素, 然后累加(accumulate), 所有的计算延迟到accumulate累加遍历的时候发生</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> total = <span class="hljs-built_in">accumulate</span> (<br>                        view::<span class="hljs-built_in">ints</span>(<span class="hljs-number">1</span>) | <br>                        view::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> i) &#123;<span class="hljs-keyword">return</span> i * i;&#125;) | <br>                        view::<span class="hljs-built_in">take</span>(<span class="hljs-number">10</span>), <br>                        <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>Projections(投影): 投影</strong>允许你告诉算法在操作对象的哪个成员上工作, 而无需编写复杂的lambda比较函数.</li>
</ol>
<p>假设有一个Struct Person, 需要按照年龄对一个Person的vector进行排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br>std::vector&lt;Person&gt; people = &#123;&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;, &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>&#125;, &#123;<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span>&#125;&#125;;<br><br><span class="hljs-comment">// C++17 做法 (需要自定义 lambda)</span><br>std::<span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Person&amp; a, <span class="hljs-type">const</span> Person&amp; b) &#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;);<br><br><span class="hljs-comment">// C++20 Ranges 做法 (使用投影)</span><br><span class="hljs-comment">// 最后一个参数 &amp;Person::age 就是投影，告诉 sort “请按 age 成员进行比较”</span><br>std::ranges::<span class="hljs-built_in">sort</span>(people, &#123;&#125;, &amp;Person::age);<br></code></pre></td></tr></table></figure>
<h2 id="C-20-Lambda表达式的更新">C++20 Lambda表达式的更新</h2>
<p><strong>[=, this]需要显式捕获this变量:</strong></p>
<ol>
<li>C++20之前 [=] 隐式捕获this</li>
<li>C++20开始, 需要显式捕获this: [=, this]</li>
</ol>
<p><strong>模板形式的<strong><strong>Lambda表达式</strong></strong>:</strong></p>
<p>可以在lambda表达式中使用模板语法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">[]<span class="hljs-built_in">template</span>&lt;T&gt;(T x) &#123;<span class="hljs-comment">/* ... */</span>&#125;; <br>[]<span class="hljs-built_in">template</span>&lt;T&gt;(T* p) &#123;<span class="hljs-comment">/* ... */</span>&#125;; <br>[]<span class="hljs-built_in">template</span>&lt;T, <span class="hljs-type">int</span> N&gt;(<span class="hljs-built_in">T</span> (&amp;a)[N]) &#123;<span class="hljs-comment">/* ... */</span>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>原因1:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++20之前获取vector元素类型</span><br><span class="hljs-keyword">auto</span> func = [](<span class="hljs-keyword">auto</span> vec)&#123; <br>    <span class="hljs-keyword">using</span> T = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">decltype</span>(vec)::value_type; <br>&#125;<br><br><span class="hljs-comment">// C++20</span><br><span class="hljs-keyword">auto</span> func = []&lt;<span class="hljs-keyword">typename</span> T&gt;(vector&lt;T&gt; vec)&#123; <br>    <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因2: 方便获取通用lambda<strong><strong>形参</strong></strong>类型, 访问静态函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++20之前</span><br><span class="hljs-keyword">auto</span> func = [](<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span>&amp; x)&#123; <br>    <span class="hljs-keyword">using</span> T = std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;; <br>    T copy = x; T::<span class="hljs-built_in">static_function</span>(); <br>    <span class="hljs-keyword">using</span> Iterator = <span class="hljs-keyword">typename</span> T::iterator; <br>&#125;<br><br><span class="hljs-comment">// C++20开始</span><br><span class="hljs-keyword">auto</span> func = []&lt;<span class="hljs-keyword">typename</span> T&gt;(<span class="hljs-type">const</span> T&amp; x)&#123; <br>    T copy = x; T::<span class="hljs-built_in">static_function</span>(); <br>    <span class="hljs-keyword">using</span> Iterator = <span class="hljs-keyword">typename</span> T::iterator; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因3: 完美转发</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++20之前</span><br><span class="hljs-keyword">auto</span> func = [](<span class="hljs-keyword">auto</span>&amp;&amp; ...args) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo</span>(std::forward&lt;<span class="hljs-keyword">decltype</span>(args)&gt;(args)...); <br>&#125;<br><br><span class="hljs-comment">// C++20</span><br><span class="hljs-keyword">auto</span> func = []&lt;<span class="hljs-keyword">typename</span> …T&gt;(T&amp;&amp; …args)&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">foo</span>(std::forward(args)...); <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Lambda表达式****捕获支持打包展开(Pack Expansion)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++20之前</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt; </span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">delay_invoke</span><span class="hljs-params">(F f, Args... args)</span></span>&#123; <br>    <span class="hljs-keyword">return</span> [f, args...]&#123; <br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">invoke</span>(f, args...); <br>    &#125; <br>&#125;<br><br><span class="hljs-comment">// C++20</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt; </span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">delay_invoke</span><span class="hljs-params">(F f, Args... args)</span></span>&#123; <br>    <span class="hljs-comment">// Pack Expansion:  args = std::move(args)...  </span><br>    <span class="hljs-keyword">return</span> [f = std::<span class="hljs-built_in">move</span>(f), args = std::<span class="hljs-built_in">move</span>(args)...]()&#123; <br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">invoke</span>(f, args...); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-常量表达式-constexpr-的更新">C++20 常量表达式(constexpr)的更新</h2>
<ol>
<li>constexpr虚函数: <strong>constexpr虚函数可以重写非constexpr的虚函数</strong> <strong>非constexpr虚函数可以重写constexpr的虚函数</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-comment">// 允许虚函数是 constexpr</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br>    <span class="hljs-comment">// 重写为另一个 constexpr 函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AnotherDerived</span> : Base &#123;<br>    <span class="hljs-comment">// 非 constexpr 虚函数重写 constexpr 虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 这个函数可以在编译期执行多态调用</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">get_result</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; obj)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-built_in">get_value</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// === 编译期多态 ===</span><br>    <span class="hljs-keyword">constexpr</span> Derived d;<br>    <span class="hljs-comment">// get_result(d) 在编译时就计算出了结果 10</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">get_result</span>(d) == <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// === 运行时多态 ===</span><br>    AnotherDerived ad;<br>    <span class="hljs-comment">// 因为 AnotherDerived::get_value() 不是 constexpr,</span><br>    <span class="hljs-comment">// 所以 get_result(ad) 只能在运行时计算</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">get_result</span>(ad) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 100</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>constexpr函数可以使用dynamic_cast和typeid 为了配合编译期多态, dynamic_cast和typeid也被扩展到了constexpr上下文中, 允许在编译期进行安全的向下转型和类型识别</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-comment">// (使用上面定义的 Base 和 Derived 类)</span><br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">is_derived</span><span class="hljs-params">(<span class="hljs-type">const</span> Base&amp; obj)</span> </span>&#123;<br>    <span class="hljs-comment">// 在编译期使用 typeid</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(obj) == <span class="hljs-built_in">typeid</span>(Derived)) &#123;<br>        <span class="hljs-comment">// 在编译期使用 dynamic_cast</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">dynamic_cast</span>&lt;<span class="hljs-type">const</span> Derived*&gt;(&amp;obj) != <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> Derived d;<br>    <span class="hljs-keyword">constexpr</span> Base b;<br><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">is_derived</span>(d) == <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">is_derived</span>(b) == <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li>动态分配内存(new / delete): 在一次常量表达式求值中, 任何通过new分配的内存, 都必须在同一次求值结束前通过delete释放, <strong>内存不能从编译期&quot;泄漏&quot;到运行时.</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><br><span class="hljs-comment">// 在编译期创建一个数组，填充它，计算总和，然后销毁它</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">sum_first_n</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 编译期动态内存分配</span><br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        arr[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        sum += arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 必须在函数结束前释放内存</span><br>    <span class="hljs-keyword">delete</span>[] arr;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 55 (1+2+...+10) 在编译时就被计算出来了</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sum_first_n</span>(<span class="hljs-number">10</span>) == <span class="hljs-number">55</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>更改union的活动成员 C++20之前, 在constexpr函数中只能读取union的活动成员, 现在, 可以在编译期改变union的活动成员, 这使得处理更复杂的数据结构成为可能</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">MyUnion</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">float</span> f;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> <span class="hljs-title">process_union</span><span class="hljs-params">()</span> </span>&#123;<br>    MyUnion u;<br>    u.i = <span class="hljs-number">5</span>; <span class="hljs-comment">// 激活成员 i</span><br>    <span class="hljs-type">int</span> val = u.i;<br><br>    u.f = <span class="hljs-number">2.5f</span> * val; <span class="hljs-comment">// 更改活动成员为 f</span><br>    <span class="hljs-keyword">return</span> u.f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">process_union</span>() == <span class="hljs-number">12.5f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li>Try / catch块 constexpr函数现在可以包含 try / catch块, 这使得更多已有的, 包含错误的库代码可以被constexpr化 在常量求值期间, 执行throw表达式是非法的, 这意味着在static_assert或其他编译期上下文中, catch块必须是不可达的.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">constexpr <span class="hljs-type">int</span> <span class="hljs-title function_">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 这个分支如果在常量求值时被执行，会导致编译错误</span><br>            <span class="hljs-comment">// throw &quot;Division by zero!&quot;; </span><br>            <span class="hljs-comment">// C++20 不允许 throw, 但我们可以用一个不会被执行的 return 来模拟</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 只是为了让代码通过编译</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a / b;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 这个 catch 块在常量求值期间必须是不可达的</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// OK: b 不为 0, try 块正常执行，catch 不可达</span><br>    static_assert(divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// divide(10, 0); // 如果取消这行注释，会导致编译错误，因为</span><br>                      <span class="hljs-comment">// if (b == 0) 分支会在常量求值时被触发</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个特性的主要目的是代码复用, 可以编写一个同时用于运行时和编译期的函数, 它在运行时可以处理异常, 而在编译期, 必须保证不会触发异常.</p>
<h2 id="C-20-constexpr-string-vector">C++20 constexpr string&amp;vector</h2>
<p>在 C++20 之前，<code>constexpr</code> 函数中严禁使用 <code>new</code> 和 <code>delete</code>，因为编译期无法管理动态内存。这直接导致了任何依赖动态内存的类型（如 <code>std::vector</code> 和 <code>std::string</code>）都无法在编译期使用.</p>
<p>C++20 改变了这一点，但有一个核心限制：<strong>在一次常量表达式求值中，任何</strong> <strong><code>new</code></strong> <strong>出来的内存在求值结束前必须被</strong> <strong><code>delete</code>。内存不能从编译期“泄漏”到运行时.</strong></p>
<p>正是这个关键的解锁，才使得 <code>std::vector</code> 和 <code>std::string</code> 的成员函数（如 <code>push_back</code>, <code>resize</code>, <code>append</code> 等）可以被标记为 <code>constexpr</code></p>
<p><strong>Constexpr</strong> <strong>std::vector : 在编译期生成一个斐波那契数列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 一个在编译期生成斐波那契数列的函数</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">generate_fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> std::array&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-number">0</span>&gt;&#123;&#125;;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 在编译期创建一个 std::vector 作为临时存储</span><br>    std::vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; fib_vec;<br>    fib_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>        fib_vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 在编译期循环，使用 push_back 填充 vector</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>        fib_vec.<span class="hljs-built_in">push_back</span>(fib_vec[i - <span class="hljs-number">1</span>] + fib_vec[i - <span class="hljs-number">2</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 将 vector 的结果复制到一个 std::array 中并返回</span><br>    <span class="hljs-comment">//    std::array 是一个固定大小的、可以在编译期实例化的容器</span><br>    std::array&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, 10&gt; result&#123;&#125;; <span class="hljs-comment">// 注意：这里为了简化，大小写死了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; fib_vec.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        result[i] = fib_vec[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result; <br>    <span class="hljs-comment">// 函数结束，fib_vec 被销毁，它在编译期申请的内存也被释放。</span><br>    <span class="hljs-comment">// 整个过程符合 constexpr 的内存规则。</span><br>&#125;<br><br><span class="hljs-comment">// 在编译时调用函数，结果直接被“烘焙”到程序中</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> fib_sequence = <span class="hljs-built_in">generate_fibonacci</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 验证结果在编译期是正确的</span><br>    <span class="hljs-built_in">static_assert</span>(fib_sequence[<span class="hljs-number">9</span>] == <span class="hljs-number">34</span>);<br><br>    <span class="hljs-comment">// 在运行时直接使用这个编译期生成的数组</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Compile-time generated Fibonacci sequence:&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> val : fib_sequence) &#123;<br>        std::cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 0 1 1 2 3 5 8 13 21 34 </span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Constexpr</strong> <strong>std</strong>**::string : 在编译期构建一个<strong><strong>CSV</strong></strong>格式的头部字符串**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><br><span class="hljs-comment">// 在编译期构建一个字符串</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">create_header</span><span class="hljs-params">(std::string_view title, <span class="hljs-type">int</span> version)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 在编译期创建 std::string 对象</span><br>    std::string header;<br><br>    <span class="hljs-comment">// 2. 在编译期使用 append, += 等操作</span><br>    header.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;Title: &quot;</span>);<br>    header.<span class="hljs-built_in">append</span>(title);<br>    header += <span class="hljs-string">&quot;, Version: &quot;</span>;<br>    header += std::<span class="hljs-built_in">to_string</span>(version); <span class="hljs-comment">// std::to_string 还不是 constexpr, 这是个痛点</span><br>                                       <span class="hljs-comment">// 但我们可以自己实现一个 constexpr 版本</span><br>    <br>    <span class="hljs-comment">// 为了演示，我们手动拼接数字</span><br>    <span class="hljs-comment">// 真实场景需要一个 constexpr 的整数转字符串函数</span><br>    <span class="hljs-keyword">if</span> (version == <span class="hljs-number">20</span>) &#123;<br>        header += <span class="hljs-string">&quot;20&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 将结果复制到 std::array 以便返回</span><br>    <span class="hljs-comment">//    这里假设我们能预估一个最大长度</span><br>    std::array&lt;<span class="hljs-type">char</span>, 64&gt; result&#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; result.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; i &lt; header.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        result[i] = header[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> header_str = <span class="hljs-built_in">create_header</span>(<span class="hljs-string">&quot;MyLib&quot;</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 验证编译期结果</span><br>    <span class="hljs-built_in">static_assert</span>(std::<span class="hljs-built_in">string_view</span>(header_str.<span class="hljs-built_in">data</span>()).<span class="hljs-built_in">starts_with</span>(<span class="hljs-string">&quot;Title: MyLib&quot;</span>));<br><br>    <span class="hljs-comment">// 运行时直接使用</span><br>    std::cout &lt;&lt; header_str.<span class="hljs-built_in">data</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Title: MyLib, Version: 20</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>未来需要支持constexpr反射</strong></p>
<h2 id="C-20-原子-Atomic-智能指针">C++20 原子(Atomic)智能指针</h2>
<p><strong>智能指针(shared_ptr)线程安全么 ?</strong></p>
<p>是: 引用计数控制单元线程安全, 保证对象只被释放一次</p>
<p>否: 对于数据的读写没有线程安全</p>
<p><strong>如何将智能指针变成线程安全的?</strong></p>
<ul>
<li>使用 <code>mutex</code> 控制智能指针的访问</li>
<li>使用全局非成员原子操作函数访问, 诸如: std::atomic_load(), atomic_store(), … 缺点: 容易出错, 忘记使用这些操作</li>
<li>C++20: <code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code>, <code>atomic&lt;weak_ptr&lt;T&gt;&gt;</code> 内部原理可能使用了<code>mutex</code> 全局非成员原子操作函数标记为不推荐使用(deprecated)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">concurrent_stack</span> &#123; <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123; <br>        T t; <br>        shared_ptr&lt;Node&gt; next; <br>    &#125;; <br>    atomic_shared_ptr&lt;Node&gt; head; <br>    <span class="hljs-comment">// C++11: 去掉 &quot;atomic_&quot; 并且在访问时, 需要用 </span><br>    <span class="hljs-comment">// 特殊的函数控制线程安全, 例如用std::tomic_load </span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">reference</span> &#123; <br>        shared_ptr&lt;Node&gt; p; <br>        &lt;snip&gt; <br>    &#125;; <br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">find</span><span class="hljs-params">(T t)</span> <span class="hljs-type">const</span> </span>&#123; <br>        <span class="hljs-keyword">auto</span> p = head.<span class="hljs-built_in">load</span>(); <span class="hljs-comment">// C++11: atomic_load(&amp;head) </span><br>        <span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;t != t) <br>            p = p-&gt;next; <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reference</span>(<span class="hljs-built_in">move</span>(p)); <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reference</span>(head); <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(T t)</span> </span>&#123; <br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">make_shared</span>&lt;Node&gt;(); <br>        p-&gt;t = t; p-&gt;next = head; <br>        <span class="hljs-keyword">while</span> (!head.<span class="hljs-built_in">compare_exchange_weak</span>(p-&gt;next, p))&#123; <br>    &#125; <span class="hljs-comment">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p-&gt;next, p); &#125;     </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">auto</span> p = head.<span class="hljs-built_in">load</span>(); <br>        <span class="hljs-keyword">while</span> (p &amp;&amp; !head.<span class="hljs-built_in">compare_exchange_weak</span>(p, p-&gt;next)) &#123;<br>        &#125; <span class="hljs-comment">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p, p-&gt;next); </span><br>    &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-自动合流-Joining-可中断-Cancellable-的线程">C++20 自动合流(Joining), 可中断(Cancellable)的线程</h2>
<p>C++20引入的std::jthread和相关的中断机制(&lt;stop_token&gt;), 解决了长期以来使用std::thread时的两个核心痛点: <strong>资源泄漏</strong>和<strong>缺乏协作式中断机制</strong></p>
<p><strong>析构行为危险:</strong></p>
<p>如果一个std::thread对象在析构时, 它所代表的线程仍在运行(既没有被join()等待结束, 也没有被detach()分离), 程序会直接调用std::terminate()导致崩溃</p>
<p><strong>没有内置的中断机制:</strong></p>
<p>std::thread没有提供一种标准的方式来&quot;通知&quot;一个正在运行的线程&quot;停下来&quot;, 开发者不得不手动实现一套中断机制, 通常是通过共享一个std::atomic<bool>标志, 然后在线程的循环中不断检查这个标志.</p>
<p><strong>std::jthread : 一个更安全的线程类</strong></p>
<p>std::jthread(Joining Thread)可以看作是std::thread的一个智能, 安全的替代品, 它的行为类似于RAII(资源获取即初始化)风格的智能指针.</p>
<p>核心行为: 当一个std::jthread 对象离开其作用域并被析构时, 如果它所关联的线程仍在运行, 它的析构函数会自动调用.join()来等待该线程执行完毕.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C++17: 必须手动 join，否则在 some_condition 为 true 时程序会崩溃</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">legacy_thread_func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]&#123; <span class="hljs-comment">/* ... */</span> &#125;)</span></span>;<br>    <span class="hljs-keyword">if</span> (some_condition) &#123;<br>        <span class="hljs-comment">// 如果这里 return, t 的析构函数会被调用，程序 terminate</span><br>        <span class="hljs-keyword">return</span>; <br>    &#125;<br>    t.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 必须在这里 join</span><br>&#125;<br><br><span class="hljs-comment">// C++20: jthread 自动管理生命周期</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modern_thread_func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::jthread <span class="hljs-title">t</span><span class="hljs-params">([]&#123; <span class="hljs-comment">/* ... */</span> &#125;)</span></span>;<br>    <span class="hljs-keyword">if</span> (some_condition) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 完全安全！t 的析构函数会自动 join</span><br>    &#125;<br>    <span class="hljs-comment">// 这里也不需要手动 join</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>可中断(Cancellable)线程: 协作式中断机制</strong></p>
<p>std::jthread的另一个强大之处在于它与&lt;stop_token&gt;头文字中定义的中断机制无缝集成, 这是一个协作式(cooperative)的中断模型, 意味着线程不会被强制杀死, 而是被&quot;礼貌地请求&quot;停止, 由线程自己决定在何时何地安全地响应这个请求</p>
<p>这个机制由三个核心组件构成:</p>
<ol>
<li><code>std::stop_source</code> (中断请求的发起者)</li>
</ol>
<ul>
<li><strong>作用</strong>：它是一个<strong>可以发出“停止请求”的对象</strong>。你可以把它看作是中断信号的“遥控器”或“按钮”。</li>
<li><strong>核心方法</strong>：<code>request_stop()</code>。调用此方法后，所有与此 <code>stop_source</code> 关联的 <code>stop_token</code> 都会变为“停止状态”。</li>
<li><strong><code>std::jthread</code></strong> <strong>的集成</strong>：每个 <code>std::jthread</code> 内部都<strong>自动包含</strong>一个 <code>std::stop_source</code>。</li>
</ul>
<ol start="2">
<li><code>std::stop_token</code> (中断状态的查询者)</li>
</ol>
<ul>
<li><strong>作用</strong>：它是一个<strong>轻量级的、只能查询的对象</strong>，用于检查是否已经收到了停止请求。你可以把它看作是中断信号的“接收器”或“状态指示灯”。</li>
<li><strong>核心方法</strong>：<code>stop_requested()</code>。线程内部通过调用这个方法来检查“我是否应该停下来了？”。如果返回 <code>true</code>，就应该准备退出。</li>
<li><strong><code>std::jthread</code></strong> <strong>的集成</strong>：当你创建一个 <code>std::jthread</code> 时，你可以让它的入口函数接受一个 <code>std::stop_token</code> 作为参数，<code>jthread</code> 会自动将它内部 <code>stop_source</code> 对应的 <code>stop_token</code> 传递进去。</li>
</ul>
<ol start="3">
<li><code>std::stop_callback</code> (中断请求的响应器)</li>
</ol>
<ul>
<li><strong>作用</strong>：它是一个 RAII 风格的类，用于<strong>注册一个回调函数</strong>。当它所关联的 <code>stop_token</code> 被请求停止时，这个回调函数会被<strong>立即同步调用</strong>。</li>
<li><strong>核心用途</strong>：这对于唤醒那些正在<strong>阻塞等待</strong>的线程（例如，等待 <code>std::condition_variable</code>）至关重要。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stop_token&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; task_queue;<br>std::mutex mtx;<br>std::condition_variable_any cv;<br><br><span class="hljs-comment">// 工作线程的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(std::stop_token token)</span> </span>&#123; <span class="hljs-comment">// 1. 接收一个 stop_token</span><br>    <span class="hljs-keyword">while</span> (!token.<span class="hljs-built_in">stop_requested</span>()) &#123; <span class="hljs-comment">// 2. 在循环的开始检查中断信号</span><br>        <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        <br>        <span class="hljs-comment">// 3. 使用 stop_token 优雅地处理等待</span><br>        <span class="hljs-comment">//    cv.wait 会等待，直到被 notify 或被中断</span><br>        <span class="hljs-keyword">if</span> (!cv.<span class="hljs-built_in">wait</span>(lock, token, []&#123; <span class="hljs-keyword">return</span> !task_queue.<span class="hljs-built_in">empty</span>(); &#125;)) &#123;<br>            <span class="hljs-comment">// 如果 wait 是因为 stop 被请求而返回，则直接退出</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Worker: Stop requested while waiting. Exiting.\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果被正常唤醒，处理任务</span><br>        <span class="hljs-type">int</span> task = task_queue.<span class="hljs-built_in">front</span>();<br>        task_queue.<span class="hljs-built_in">pop</span>();<br>        lock.<span class="hljs-built_in">unlock</span>();<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Worker: Processing task &quot;</span> &lt;&lt; task &lt;&lt; std::endl;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Worker: Stop requested. Cleanly exiting loop.\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 4. 创建 jthread，它会自动处理 stop_source 和 stop_token</span><br>    <span class="hljs-function">std::jthread <span class="hljs-title">worker_thread</span><span class="hljs-params">(worker)</span></span>;<br><br>    <span class="hljs-comment">// 模拟向队列中添加任务</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">200</span>));<br>        &#123;<br>            <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>            task_queue.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main: All tasks pushed. Requesting stop.\n&quot;</span>;<br>    <span class="hljs-comment">// 5. jthread 的析构函数会自动调用 stop_source.request_stop()</span><br>    <span class="hljs-comment">//    我们也可以手动调用来提前请求停止</span><br>    <span class="hljs-comment">// worker_thread.request_stop(); </span><br>    <br>    <span class="hljs-comment">// main 函数结束，worker_thread 的析构函数会被调用。</span><br>    <span class="hljs-comment">// 在析构函数中，它会：</span><br>    <span class="hljs-comment">// a) 调用 request_stop() (如果还没调用过)</span><br>    <span class="hljs-comment">// b) 调用 join() 等待线程结束</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li><code>worker</code> 函数接受一个 <code>std::stop_token</code>，这是 <code>jthread</code> 自动传入的。</li>
<li>循环的条件是 <code>!token.stop_requested()</code>，这是标准的、非阻塞的检查方式。</li>
<li><code>cv.wait(lock, token, ...)</code> 是一个关键的 C++20 新重载。它允许 <code>condition_variable_any</code> 不仅可以被 <code>notify</code> 唤醒，也可以被 <code>stop_token</code> 的停止请求“唤醒”。这完美解决了旧的中断模型难以处理阻塞等待的问题。</li>
<li>在 <code>main</code> 函数中，我们创建 <code>std::jthread</code>，完全不需要手动管理 <code>stop_source</code>。</li>
<li>当 <code>main</code> 函数结束，<code>worker_thread</code> 的析构函数会自动执行 <code>request_stop()</code>，这会导致 <code>worker</code> 线程中的 <code>token.stop_requested()</code> 变为 <code>true</code>，或者唤醒正在 <code>cv.wait</code> 的线程，从而使线程能够优雅地退出循环并结束。然后，析构函数再安全地 <code>join()</code> 它。</li>
</ol>
<h2 id="C-20-同步-Synchronization-库">C++20 同步(Synchronization)库</h2>
<ol>
<li><strong>信号量(Semaphores)</strong></li>
</ol>
<p>头文件: <semaphore></p>
<p>信号量是一个广义的计数器, 用于管理对有限数量资源的访问:</p>
<p>计数器: 信号量初始计数值为 N</p>
<p>获取资源: 获取资源, N &gt; 0, N–; N = 0, 该任务必须等待(阻塞)</p>
<p>释放资源: N++, 有等待的任务, 此时可以被唤醒进入</p>
<p><strong>两种类型的信号量:</strong></p>
<p><strong>std::counting_semaphore<N> (多元信号量)</strong></p>
<p>最通用的信号量, 计数器可以从N开始, 最大值也是N, 适用于有一组<strong>完全相同</strong>的资源池: 1. 数据库连接池 2. 线程池中有限数量的工作线程 3. GPU内存中有限的缓冲区数量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 最多允许 3 个线程同时访问某个资源</span><br><span class="hljs-function">std::counting_semaphore&lt;3&gt; <span class="hljs-title">semaphore</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access_resource</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    semaphore.<span class="hljs-built_in">acquire</span>(); <span class="hljs-comment">// 请求一个资源，如果满了就等待</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is accessing the resource.\n&quot;</span>;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is releasing the resource.\n&quot;</span>;<br>    semaphore.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放资源</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::jthread&gt; threads;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(access_resource, i);<br>    &#125;<br>&#125; <span class="hljs-comment">// jthread 会自动 join</span><br></code></pre></td></tr></table></figure>
<p><strong>std::binary_semaphore(二元信号量):</strong></p>
<p>std::counting_semaphore&lt;1&gt; 的特化版本, 计数器只能是0或1.</p>
<p>当资源是独占的(要么可用, 要么不可用)时, 它本质就是一个<strong>轻量的, 无所有权的互斥锁(mutex),</strong> 它比std::mutex更底层, 因为它不关心是哪个线程release的.</p>
<ol>
<li>std::atomic的等待和通知接口</li>
</ol>
<p>为原子变量(如 std::atomic<bool>或 std::atomic<int>) 增加了一种高效的等待机制, 以取代消耗CPU的&quot;忙等待&quot;(也叫轮询或者自旋)</p>
<p><strong>忙等待:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 低效的旧方法</span><br>std::atomic&lt;<span class="hljs-type">bool</span>&gt; data_ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 疯狂消耗 CPU，直到 data_ready 变为 true</span><br>    <span class="hljs-keyword">while</span> (!data_ready.<span class="hljs-built_in">load</span>()) &#123; <span class="hljs-comment">/* busy wait */</span> &#125; <br>    <span class="hljs-comment">// process data...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>C++20解决忙等待的方法:</strong></p>
<ul>
<li><strong><code>wait(old_value)</code></strong>：如果原子变量的当前值等于 <code>old_value</code>，则<strong>阻塞</strong>当前线程，让出 CPU。</li>
<li><strong><code>notify_one()</code></strong> <strong>/</strong> <strong><code>notify_all()</code></strong>：当原子变量的值被修改后，调用 <code>notify</code> 来<strong>唤醒</strong>一个或所有正在 <code>wait</code> 的线程。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br>std::atomic&lt;<span class="hljs-type">bool</span>&gt; data_ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer is waiting...\n&quot;</span>;<br>    <span class="hljs-comment">// 如果 data_ready 的值是 false，就阻塞线程</span><br>    <span class="hljs-comment">// 如果它不是 false (即 true)，就立即继续</span><br>    data_ready.<span class="hljs-built_in">wait</span>(<span class="hljs-literal">false</span>); <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer found data is ready!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Producer is preparing data...\n&quot;</span>;<br>    data_ready.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Producer notifies all.\n&quot;</span>;<br>    data_ready.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 唤醒所有在 wait(false) 的线程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::jthread <span class="hljs-title">t1</span><span class="hljs-params">(consumer)</span></span>;<br>    <span class="hljs-function">std::jthread <span class="hljs-title">t2</span><span class="hljs-params">(producer)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种方式在等待期间基本不消耗CPU, 比忙等待高效得多, 适用于一些比条件变量更简单的&quot;标志位&quot;同步场景</p>
<ol start="3">
<li>锁存器(Latches)和屏障(Barriers)</li>
</ol>
<p>锁存器和屏障都是用于群体同步的原语, 即让一组线程在某个点上&quot;集合&quot;或&quot;同步&quot;</p>
<p><strong>std::latch(锁存器):</strong></p>
<latch>
<p><strong>核心思想</strong>：一个<strong>一次性</strong>的同步屏障。它像一个倒计时门。</p>
<ul>
<li><strong>初始化</strong>：创建一个 <code>std::latch(N)</code>，<code>N</code> 是需要等待的线程数。</li>
<li><strong>倒计时</strong>：每个线程完成任务后调用 <code>.count_down()</code>，计数器减一。</li>
<li><strong>等待</strong>：主线程（或任何其他线程）调用 <code>.wait()</code>，它会阻塞在这里。</li>
<li><strong>开门</strong>：当计数器减到 <code>0</code> 时，门被<strong>永久打开</strong>，所有在 <code>wait()</code> 的线程都被释放，并且之后任何调用 <code>.wait()</code> 的线程都会立即通过。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;latch&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">std::latch <span class="hljs-title">all_workers_done</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">// 等待 3 个工作线程</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; is doing work.\n&quot;</span>;<br>    <span class="hljs-comment">// ... do work ...</span><br>    all_workers_done.<span class="hljs-built_in">count_down</span>(); <span class="hljs-comment">// 完成工作，计数减一</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::jthread&gt; threads;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>(worker, i);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main thread is waiting for all workers to finish.\n&quot;</span>;<br>    all_workers_done.<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// 阻塞，直到计数器为 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;All workers are done. Main thread proceeds.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>std::barrier(屏障):</strong></p>
<barrier>
<p><strong>核心思想</strong>：一个<strong>可重复使用</strong>的同步点，用于将并行算法分为多个<strong>阶段 (phase)</strong>。</p>
<ul>
<li><strong>初始化</strong>：创建一个 <code>std::barrier(N)</code>，<code>N</code> 是参与同步的线程数。</li>
<li><strong>到达并等待</strong>：每个线程在一个阶段的末尾调用 <code>.arrive_and_wait()</code>。它会阻塞，直到所有 <code>N</code> 个线程都调用了此方法。</li>
<li><strong>阶段完成</strong>：当第 <code>N</code> 个线程到达时，屏障打开。
<ul>
<li>可选的<strong>完成函数</strong>会被执行（通常由最后一个到达的线程执行）。</li>
<li>所有线程被释放，<strong>进入下一个阶段</strong>。</li>
<li>屏障自动重置，为下一阶段的同步做准备。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 屏障，参与者是 3 个工作线程 + 1 个主线程 = 4</span><br><span class="hljs-function">std::barrier <span class="hljs-title">sync_point</span><span class="hljs-params">(<span class="hljs-number">4</span>, []() <span class="hljs-keyword">noexcept</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// 这是阶段完成函数，在每个阶段结束时被调用</span></span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;----------- Phase Complete -----------\n&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id, std::string task)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; starting &quot;</span> &lt;&lt; task &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-comment">// ... do work for this phase ...</span><br>    sync_point.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 到达屏障，等待其他线程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::jthread&gt; threads;<br>    threads.<span class="hljs-built_in">emplace_back</span>(worker, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Phase 1: Task A&quot;</span>);<br>    threads.<span class="hljs-built_in">emplace_back</span>(worker, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Phase 1: Task B&quot;</span>);<br>    threads.<span class="hljs-built_in">emplace_back</span>(worker, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Phase 1: Task C&quot;</span>);<br><br>    <span class="hljs-comment">// 主线程也参与同步</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main thread starting Phase 1\n&quot;</span>;<br>    sync_point.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 等待所有线程完成阶段1</span><br><br>    <span class="hljs-comment">// 此时所有线程都被释放，可以开始下一阶段</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Main thread starting Phase 2\n&quot;</span>;<br>    sync_point.<span class="hljs-built_in">arrive_and_wait</span>(); <span class="hljs-comment">// 等待所有线程完成阶段2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-std-atomic-ref">C++20 std::atomic_ref</h2>
<p>std::atomic_ref允许你将一个普通的, 非原子(non-atomic)的对象, <strong>临时地, 像原子对象一样去操作, 而无需改变这个对象本身的类型.</strong></p>
<p>在C++20之前, 假设你有一个struct或者class, 其中包含一个普通的int成员, 你希望在某个特定的场景下, 对这个int成员进行原子操作, 有两种方式实现:</p>
<ol>
<li>将 <code>int value;</code> 直接改成 <code>std::atomic&lt;int&gt; value;</code> 这会永久性的改变Counter的含义, std::atomic<T>通常比T本身体积更大, 且可能无法被拷贝或者移动, 这可能会破坏类的其他特性, 在非并发场景下, 访问std::atomic仍然会有原子操作的开销, 这可能是不必要的性能损失</li>
<li>使用std::mutex, 每次访问value时都加锁, 互斥锁的开销通常比原子操作要大得多, 尤其是在低竞争场景下, 需要手动, 正确的管理锁, 容易出错</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-comment">// ... 可能还有其他成员</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>std::atomic_ref&lt;T&gt;</code> 是一个模板类，它本身不拥有数据，而是<strong>引用</strong>一个外部的 <code>T</code> 类型的对象.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parallel_sum</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; sum, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 在这个函数作用域内，为普通的 int&amp; sum 创建一个原子引用</span><br>    <span class="hljs-function">std::atomic_ref&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">atomic_sum</span><span class="hljs-params">(sum)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = start; i &lt; end; ++i) &#123;<br>        <span class="hljs-comment">// 2. 通过 atomic_ref 执行原子操作</span><br>        <span class="hljs-comment">//    这和 atomic&lt;int&gt;::fetch_add 完全一样</span><br>        atomic_sum.<span class="hljs-built_in">fetch_add</span>(data[i], std::memory_order_relaxed);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">10000</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) &#123;<br>        data[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. sum 只是一个普通的 int</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function">std::jthread <span class="hljs-title">t1</span><span class="hljs-params">(parallel_sum, std::ref(sum), std::ref(data), <span class="hljs-number">0</span>, <span class="hljs-number">5000</span>)</span></span>;<br>    <span class="hljs-function">std::jthread <span class="hljs-title">t2</span><span class="hljs-params">(parallel_sum, std::ref(sum), std::ref(data), <span class="hljs-number">5000</span>, <span class="hljs-number">10000</span>)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br><br>    <span class="hljs-comment">// 4. 当线程结束后，sum 仍然是一个普通的 int，可以直接访问</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 正确的结果应该是 (1+10000)*10000/2 = 50005000</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Expected: &quot;</span> &lt;&lt; <span class="hljs-number">50005000</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-指定初始化-Designated-Initializers">C++20 指定初始化(Designated Initializers)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> &#123; <br>    <span class="hljs-type">int</span> anInt = <span class="hljs-number">0</span>; <br>    std::string aString; <br>&#125;; <br>Data d&#123; .aString = <span class="hljs-string">&quot;Hello&quot;</span> &#125;;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-航天飞机操作符-三路比较运算符">C++20 航天飞机操作符&lt;=&gt; (三路比较运算符)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">(a &lt;=&gt; b) &lt; <span class="hljs-number">0</span> <span class="hljs-comment">// 如果 a &lt; b 则为 true</span><br>(a &lt;=&gt; b) &gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 如果 a &gt; b 则为 true</span><br>(a &lt;=&gt; b) == <span class="hljs-number">0</span> <span class="hljs-comment">// 如果 a 与 b 相等或者等价 则为 true</span><br><br><span class="hljs-comment">// 类似于C的strcmp 函数返回-1, 0, 1</span><br></code></pre></td></tr></table></figure>
<p><strong>一般情况:</strong> 自动生成所有的比较操作符**,** 如果对象是结构体则逐个比较, 可以用下面的代码代替所有的比较运算符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> X::<span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Y&amp;) = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure>
<p><strong>高级情况:</strong> 指定返回类型(支持6种所有的比较运算符)</p>
<p><img src="%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="指定返回类型" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123; <br>    <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b)&#123; <br>        <span class="hljs-keyword">return</span> a.x==b.x &amp;&amp; a.y==b.y; <br>    &#125; <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b)&#123; <br>        <span class="hljs-keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);  <br>    &#125; <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b) &#123; <br>        <span class="hljs-keyword">return</span> !(a==b); <br>    &#125; <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b) &#123; <br>        <span class="hljs-keyword">return</span> !(<span class="hljs-built_in">b</span>&lt;a); <br>    &#125; <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt; (<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b) &#123; <br>        <span class="hljs-keyword">return</span> b&lt;a; <br>    &#125; <br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Point&amp; a, <span class="hljs-type">const</span> Point&amp; b) &#123; <br>        <span class="hljs-keyword">return</span> !(a&lt;b); <br>    &#125; <br>    <span class="hljs-comment">// ... 其他非比较函数 ... </span><br>&#125;; <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;compare&gt;</span> </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123; <br>    <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y; <br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Point&amp;)  <span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 比较操作符自动生成</span><br>    <span class="hljs-comment">// ... 其他非比较函数 ... </span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>标准库类型支持</strong>: vector, string, map, set, sub_match, …</p>
<p><img src="%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81.png" srcset="/Diffcc/Diffcc.github.io/img/loading.gif" lazyload alt="标准库类型支持" /></p>
<h2 id="C-20-范围for循环语句支持初始化语句">C++20 范围for循环语句支持初始化语句</h2>
<p>switch 语句初始化 (C++17):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <br>    <span class="hljs-type">int</span> value; <span class="hljs-type">int</span> result; <br>&#125;; <br><span class="hljs-function">Foo <span class="hljs-title">GetData</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(); <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">GetData</span>(); data.value) &#123; <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>        <span class="hljs-keyword">return</span> data.result; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>if 语句初始化 (C++17):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <br>    <span class="hljs-type">int</span> value; <span class="hljs-type">int</span> result; <br>&#125;; <br><span class="hljs-function">Foo* <span class="hljs-title">GetData</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(); <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">GetData</span>(); data) &#123; <br>        <span class="hljs-comment">// Use &#x27;data’ </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在范围 for 循环同样支持初始化 (C++20):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; values; <br>&#125;; <br><span class="hljs-function">Foo <span class="hljs-title">GetData</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(); <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">GetData</span>(); <br>    <span class="hljs-keyword">auto</span>&amp; value : data.values) &#123; <br>        <span class="hljs-comment">// Use &#x27;data’ </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-非类型模板形参支持字符串">C++20 非类型模板形参支持字符串</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span>&amp; s&gt; <span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span> </span>&#123; <br>    std::cout &lt;&lt; s &lt;&lt; std::endl; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-built_in">DoSomething</span>&lt;<span class="hljs-string">&quot;CppCon&quot;</span>&gt;(); <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-likely-unlikely">C++20 [[likely]], [[unlikely]]</h2>
<p>先验概率指导编译器优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">switch</span> (value) &#123; <br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>; <br>    [[likely]] <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">break</span>; <br>    [[unlikely]] <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">break</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-日历-Calendar-和时区-Timezone-功能">C++20 日历(Calendar)和时区(Timezone)功能</h2>
<p>增加日历和时区的支持</p>
<p>只支持公历(Gregorian calendar)</p>
<p>初始化年, 月, 日的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// creating a year </span><br><span class="hljs-type">auto</span> <span class="hljs-variable">y1</span> <span class="hljs-operator">=</span> year&#123; <span class="hljs-number">2019</span> &#125;; <br><span class="hljs-type">auto</span> <span class="hljs-variable">y2</span> <span class="hljs-operator">=</span> 2019y; <br><span class="hljs-comment">// creating a mouth</span><br><span class="hljs-type">auto</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> month&#123; <span class="hljs-number">9</span> &#125;; <br><span class="hljs-type">auto</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> September; <br><span class="hljs-comment">// creating a day </span><br><span class="hljs-type">auto</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> day&#123; <span class="hljs-number">18</span> &#125;; <br><span class="hljs-type">auto</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-number">18d</span>;<br></code></pre></td></tr></table></figure>
<p>创建完整的日期</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">year_mouth_day fulldate1&#123;<span class="hljs-number">2019</span>y, September, <span class="hljs-number">18</span>d&#125;; <br><span class="hljs-keyword">auto</span> fulldate2 = <span class="hljs-number">2019</span>y / September / <span class="hljs-number">18</span>d; <br>year_mouth_day fulldate3&#123;Monday[<span class="hljs-number">3</span>]/September/<span class="hljs-number">2019</span>&#125;; <span class="hljs-comment">// Monday[3] 表示第三个星期一</span><br></code></pre></td></tr></table></figure>
<p>新的事件间隔单元, 类似于秒, 分钟,…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> days = duration&lt;<span class="hljs-type">signed</span> interger type of at least <span class="hljs-number">25</span>bits, <br>                      ratio_multiply&lt;ratio&lt;<span class="hljs-number">24</span>&gt;, hours::period&gt;&gt;; <br><span class="hljs-keyword">using</span> weeks = ...; <span class="hljs-keyword">using</span> mouths = ...; <br><span class="hljs-keyword">using</span> years = ...;<br><br>weeks w&#123;<span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 1 周 </span><br>days d&#123;w&#125;; <span class="hljs-comment">// 将 1 周 转换成天数</span><br></code></pre></td></tr></table></figure>
<h2 id="C-20-std-span">C++20 std:span</h2>
<span>
<p>提供一个统一的, 非拥有所有权的, 轻量级的视图(view)来表示任意的连续内存块</p>
<p>可以将其理解为&quot;一个知道自己长度的智能指针&quot;, 或者是&quot;std::string_view的泛型版本&quot;, std::string_view用于处理字符串, 而std::span用于处理任何类型的连续数据</p>
<p>在 C++20 之前，如果你想编写一个函数来处理一块连续的数据（比如，计算一个数组的总和），你通常会遇到 API 设计的难题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 你的数据可能来自不同的源</span><br><span class="hljs-type">int</span> c_style_array[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; my_vector = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>std::array&lt;<span class="hljs-type">int</span>, 3&gt; my_array = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br></code></pre></td></tr></table></figure>
<p>在C++20之前, 可以这么做:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// C语言风格(指针 + 长度)</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sum_elements</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* data, <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">// 调用: sum_elements(c_style_array, 5);</span><br><span class="hljs-comment">// 调用: sum_elements(my_vector.data(), my_vector.size());</span><br><span class="hljs-comment">// 缺点: 需要传递两个参数, 容易传错</span><br><br><span class="hljs-comment">// C++ 模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Container&gt;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sum_elements</span><span class="hljs-params">(<span class="hljs-type">const</span> Container&amp; cont)</span></span>;<br><span class="hljs-comment">// 调用: sum_elements(c_style_array);</span><br><span class="hljs-comment">// 调用: sum_elements(my_vector);</span><br><span class="hljs-comment">// 缺点: 模板实例化会导致代码膨胀</span><br><br><span class="hljs-comment">// C++ 重载</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sum_elements</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sum_elements</span><span class="hljs-params">(<span class="hljs-type">const</span> std::array&lt;<span class="hljs-type">int</span>, <span class="hljs-number">3</span>&gt;&amp; arr)</span></span>;<br><span class="hljs-comment">// ... 为每一种可能的数据源都写一个重载 ...</span><br><span class="hljs-comment">// 缺点: 繁琐, 无法扩展</span><br></code></pre></td></tr></table></figure>
<p>C++20 std::span</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;span&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><br><span class="hljs-comment">// 唯一的、最高效的版本</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">sum_elements</span><span class="hljs-params">(std::span&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>&gt; data)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : data) &#123;<br>        sum += val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;```<br>这个函数签名清晰地表达了它的意图：“我需要一个只读的、连续的 `<span class="hljs-type">int</span>` 序列，但我不在乎它来自哪里，也不负责管理它的生命周期。”<br><br>#### 如何使用 `std::span`<br><br>`std::span` 的美妙之处在于，你可以从各种连续内存源**隐式转换**或**显式构造**它。<br><br>```cpp<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;span&gt;</span></span><br><br><span class="hljs-comment">// (上面定义的 sum_elements 函数)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 从 C 风格数组</span><br>    <span class="hljs-type">int</span> c_style_array[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum of C array: &quot;</span> &lt;&lt; <span class="hljs-built_in">sum_elements</span>(c_style_array) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 2. 从 std::vector</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; my_vector = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum of vector: &quot;</span> &lt;&lt; <span class="hljs-built_in">sum_elements</span>(my_vector) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 3. 从 std::array</span><br>    std::array&lt;<span class="hljs-type">int</span>, 3&gt; my_array = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum of array: &quot;</span> &lt;&lt; <span class="hljs-built_in">sum_elements</span>(my_array) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 4. 创建一个指向子序列的 span</span><br>    <span class="hljs-comment">//    这个 span 只“看到” vector 的中间两个元素 &#123;7, 8&#125;</span><br>    <span class="hljs-function">std::span&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>&gt; <span class="hljs-title">sub_vector_span</span><span class="hljs-params">(my_vector.begin() + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum of sub-vector: &quot;</span> &lt;&lt; <span class="hljs-built_in">sum_elements</span>(sub_vector_span) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 5. span 也提供了类似容器的接口</span><br>    <span class="hljs-function">std::span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">modifiable_span</span><span class="hljs-params">(c_style_array)</span></span>;<br>    modifiable_span[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">// 可以通过非 const span 修改原始数据</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;C array first element after modification: &quot;</span> &lt;&lt; c_style_array[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>std::span的非拥有所有权(Non-owning), 不负责其指向的内存的分配和释放, 它只是一个临时的&quot;视图&quot;或&quot;句柄&quot;, 意味着std::span可能会悬空(dangle), 如果原始数据容器被销毁了, 指向它的span就会变得无效, 使用它将导致未定义行为, 它的生命周期管理规则与引用和指针类似.</p>
<h2 id="C-20-特性测试宏">C++20 特性测试宏</h2>
<p>通过特性宏可以判断编译器是否支持某个功能, 例如:</p>
<ol>
<li>语言特性:</li>
</ol>
<ul>
<li><code>__has_cpp_attribute(fallthrough)</code></li>
<li><code>__cpp_binary_literals</code></li>
<li><code>__cpp_char8_t</code></li>
<li><code>__cpp_coroutines</code></li>
</ul>
<ol start="2">
<li>标准库特性:</li>
</ol>
<ul>
<li><code>__cpp_lib_concepts</code></li>
<li><code>__cpp_lib_ranges</code></li>
<li><code>__cpp_lib_scoped_lock</code></li>
</ul>
<h2 id="C-20-用using引用enum类型">C++20 用using引用enum类型</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">CardTypeSuit</span> &#123; <br>    Clubs, <br>    Diamonds, <br>    Hearts, <br>    Spades <br>&#125;; <br><span class="hljs-function">std::string_view <span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-type">const</span> CardTypeSuit cardTypeSuit)</span> </span>&#123; <br>    <span class="hljs-keyword">switch</span> (cardTypeSuit) &#123; <br>    <span class="hljs-keyword">case</span> CardTypeSuit::Clubs: <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Clubs&quot;</span>; <br>    <span class="hljs-keyword">case</span> CardTypeSuit::Diamonds: <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Diamonds&quot;</span>; <br>    <span class="hljs-keyword">case</span> CardTypeSuit::Hearts: <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hearts&quot;</span>; <br>    <span class="hljs-keyword">case</span> CardTypeSuit::Spades: <br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Spades&quot;</span>; <br>    &#125; <br>&#125; <br><span class="hljs-function">std::string_view <span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-type">const</span> CardTypeSuit cardTypeSuit)</span> </span>&#123; <br>    <span class="hljs-keyword">switch</span> (cardTypeSuit) &#123; <br>        <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CardTypeSuit</span>; <span class="hljs-comment">// 这里 </span><br>        <span class="hljs-keyword">case</span> Clubs: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Clubs&quot;</span>; <br>        <span class="hljs-keyword">case</span> Diamonds: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Diamonds&quot;</span>; <br>        <span class="hljs-keyword">case</span> Hearts: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hearts&quot;</span>; <br>        <span class="hljs-keyword">case</span> Spades: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Spades&quot;</span>; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="C-20-格式化库-std-format">C++20 格式化库(std::format)</h2>
<p>不展开, 类似于Python的格式化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string s = std::format(<span class="hljs-string">&quot;Hello CppCon &#123;&#125;!&quot;</span>, <span class="hljs-number">2019</span>);<br></code></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<ol>
<li>增加数字常量</li>
</ol>
<ul>
<li>头文件</li>
<li>包含 e, log2e, log10e pi, inv_pi, inv_sqrt pi ln2, ln10 sqrt2, sqrt3, inv_sqrt3 egamma</li>
</ul>
<ol start="2">
<li>std::source_location</li>
</ol>
<p>用于获取代码位置, 对于日志和错误信息尤其有用</p>
<ol start="3">
<li>[[nodiscard(reason)]]</li>
</ol>
<p>表明返回值不可抛弃, 加入理由的支持</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">[[<span class="hljs-built_in">nodiscard</span>(<span class="hljs-string">&quot;Ignoring the return value will result in memory leaks.&quot;</span>)]] <br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">GetData</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>位运算</li>
</ol>
<p>加入循环移位, 计数0和1位等功能</p>
<ol start="5">
<li>其他小更新</li>
</ol>
<ul>
<li>字符串支持 starts_with, ends_with</li>
<li>map 支持 contains 查询是否存在某个键</li>
<li>list 和 forward list 的 remove, remove_if 和 unique 操作返回 size_type 表明删除个数</li>
<li>增加 shift_left, shift_right</li>
<li><code>midpoint</code> 计算中位数, 可避免溢出</li>
<li>lerp 线性插值 lerp( float a, float b, float t ) 返回 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SIYwBQJu-1628786141278)(<a target="_blank" rel="noopener" href="https://www.zhihu.com/equation?tex=a+%2B+t(b-a)">https://www.zhihu.com/equation?tex=a+%2B+t(b-a)</a>])</li>
<li>新的向量化策略 <code>unsequenced_policy(execution::unseq)</code></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="../../../../categories/C-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" class="category-chain-item">C++语言特性</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++新特性</div>
      <div>https://github.com/Diffcc/Diffcc.github.io/2025/09/14/20250914/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Diffcc</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年9月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="../../../08/04/20250804/" title="TransformerEngine加速库">
                        <span class="hidden-mobile">TransformerEngine加速库</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"KJGUBUZKqbURalPPi4RThE5j-gzGzoHsz","appKey":"LLhQIl1R0Kiu8YUUshoGpnuy","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访问 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="../../../../js/events.js" ></script>
<script  src="../../../../js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="../../../../js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="../../../../js/leancloud.js" ></script>

  <script  src="../../../../js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="../../../../js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
